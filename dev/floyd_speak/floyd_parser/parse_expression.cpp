//
//  parse_expression.cpp
//  FloydSpeak
//
//  Created by Marcus Zetterquist on 26/07/16.
//  Copyright © 2016 Marcus Zetterquist. All rights reserved.
//

#include "parse_expression.h"

#include "floyd_basics.h"
#include "json_support.h"
#include "ast_typeid.h"
#include "ast_value.h"
#include "ast_typeid_helpers.h"
#include "parser_primitives.h"



namespace floyd {


#define UNIT_TEST_1(function_under_test, scenario, test_expression) \
	static void QUARK_UNIQUE_LABEL(cppext_unit_test_)(); \
	static ::quark::unit_test_rec QUARK_UNIQUE_LABEL(rec)(__FILE__, __LINE__, "", function_under_test, scenario, "", QUARK_UNIQUE_LABEL(cppext_unit_test_), false); \
	static void QUARK_UNIQUE_LABEL(cppext_unit_test_)(){ if(test_expression){}else{ ::quark::on_unit_test_failed_hook(::quark::get_runtime(), ::quark::source_code_location(__FILE__, __LINE__), QUARK_STRING(exp)); } }


QUARK_UNIT_TEST("parser", "C++ operators", "", ""){
	const int a = 2-+-2;
	QUARK_TEST_VERIFY(a == 4);
}


QUARK_UNIT_TEST("parser", "C++ enum class()", "", ""){
	enum class my_enum {
		k_one = 1,
		k_four = 4
	};

	QUARK_UT_VERIFY(my_enum::k_one == my_enum::k_one);
	QUARK_UT_VERIFY(my_enum::k_one != my_enum::k_four);
	QUARK_UT_VERIFY(static_cast<int>(my_enum::k_one) == 1);
}


/*
	C99-language constants.
	http://en.cppreference.com/w/cpp/language/operator_precedence
*/
const std::string k_c99_number_chars = "0123456789.";
const std::string k_c99_whitespace_chars = " \n\t\r";
const std::string k_c99_identifier_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";

/*
	White-space policy:
	All function SUPPORT leading whitespace.
	No need to filter when you return for next function.
	Why: only one function entry, often many function exists.
*/


///////////////////////////////////			eoperator_precedence


/*
	Operator precedence is the same as C99.
	Lower number gives stronger precedence.
	Important: we use < and > to compare these.
*/
enum class eoperator_precedence {
	k_super_strong = 0,

	//	(xyz)
	k_parentesis = 0,

	//	a()
	k_function_call = 2,

	//	a[], aka subscript
	k_looup = 2,

	//	a.b
	k_member_access = 2,


	k_multiply_divider_remainder = 5,

	k_add_sub = 6,

	//	<   <=	For relational operators < and ≤ respectively
	//	>   >=
	k_larger_smaller = 8,


	k_equal__not_equal = 9,

	k_logical_and = 13,
	k_logical_or = 14,

	k_comparison_operator = 15,

	k_super_weak
};


///////////////////////////////////			eoperation


/*
	These are the operations generated by parsing the C-style expression.
	The order of constants inside enum not important.

	The number tells how many operands it needs.
*/
enum class eoperation {
	k_0_number_constant = 100,

	//	This is string specifying a local variable, member variable, argument, global etc. Only the first entry in a chain.
	k_0_resolve,

	k_0_string_literal,

	k_x_member_access,

	k_2_lookup,

	k_2_add,
	k_2_subtract,
	k_2_multiply,
	k_2_divide,
	k_2_remainder,

	k_2_smaller_or_equal,
	k_2_smaller,

	k_2_larger_or_equal,
	k_2_larger,

	//	a == b
	k_2_logical_equal,

	//	a != b
	k_2_logical_nonequal,

	//	a && b
	k_2_logical_and,

	//	a || b
	k_2_logical_or,

	//	cond ? a : b
	k_3_conditional_operator,

	k_n_call,

	//	!a
//	k_1_logical_not

	//	-a
	k_1_unary_minus,


//	k_0_identifier

//	k_1_construct_value

	k_1_vector_definition,
	k_1_dict_definition
};


static const std::map<eoperation, std::string> k_2_operator_to_string{
//	{ eoperation::k_x_member_access, "->" },

	{ eoperation::k_2_lookup, "[]" },

	{ eoperation::k_2_add, "+" },
	{ eoperation::k_2_subtract, "-" },
	{ eoperation::k_2_multiply, "*" },
	{ eoperation::k_2_divide, "/" },
	{ eoperation::k_2_remainder, "%" },

	{ eoperation::k_2_smaller_or_equal, "<=" },
	{ eoperation::k_2_smaller, "<" },
	{ eoperation::k_2_larger_or_equal, ">=" },
	{ eoperation::k_2_larger, ">" },

	{ eoperation::k_2_logical_equal, "==" },
	{ eoperation::k_2_logical_nonequal, "!=" },
	{ eoperation::k_2_logical_and, "&&" },
	{ eoperation::k_2_logical_or, "||" },
};


std::pair<ast_json_t, seq_t> parse_expression_int(const seq_t& p, const eoperator_precedence precedence);

//	Top-level function that parses entire expression into json_t.
std::pair<ast_json_t, seq_t> parse_expression2(const seq_t& p);






bool is_valid_expr_chars(const std::string& s){
	const auto allowed = k_c99_identifier_chars + k_c99_number_chars + k_c99_whitespace_chars + "+-*/%" + "\"[](){}.?:=!<>&,|#$\\;\'";
	for(auto i = 0 ; i < s.size() ; i++){
		const char ch = s[i];
		if(allowed.find(ch) == std::string::npos){
			return false;
		}
	}
	return true;
}

seq_t skip_expr_whitespace(const seq_t& p) {
	QUARK_ASSERT(p.check_invariant());

	return floyd::skip_whitespace(p);
//	return read_while(p, k_c99_whitespace_chars).second;
}

std::string expr_to_string(const json_t& e){
	return json_to_compact_string(e);
}

/*
	()
	(100)
	(100, 200)
	(get_first() * 3, 4)

	[:]
	["one": 1000, "two": 2000]
*/
struct collection_element_t {
	std::shared_ptr<json_t> _key;
	json_t _value;
};

bool operator==(const collection_element_t& lhs, const collection_element_t& rhs){
	return compare_shared_values(lhs._key, rhs._key)
	&& lhs._value == rhs._value;
}


struct collection_def_t {
	bool _has_keys;
	std::vector<collection_element_t> _elements;
};

bool operator==(const collection_def_t& lhs, const collection_def_t& rhs){
	return
		lhs._has_keys == rhs._has_keys
		&& lhs._elements == rhs._elements;
}

void ut_verify_collection(const quark::call_context_t& context, const std::pair<collection_def_t, seq_t> result, const std::pair<collection_def_t, seq_t> expected){
	if(result == expected){
	}
	else{
		quark::fail_test(context);
	}
}

//	???	Return json_t directly, no need for collection_def_t-type.
std::pair<collection_def_t, seq_t> parse_bounded_list(const seq_t& s, const std::string& start_char, const std::string& end_char){
	QUARK_ASSERT(s.check_invariant());
	QUARK_ASSERT(s.first() == start_char);
	QUARK_ASSERT(start_char.size() == 1);
	QUARK_ASSERT(end_char.size() == 1);

	auto pos = skip_expr_whitespace(s.rest1());
	if(pos.first1() == end_char){
		return {
			collection_def_t{ false, {} },
			pos.rest1()
		};
	}
	else if(pos.first1() == ":" && skip_expr_whitespace(pos.rest1()).first1() == end_char){
		return {
			collection_def_t{ true, {} },
			skip_expr_whitespace(pos.rest1()).rest1()
		};
	}
	else{
		collection_def_t result{false, {}};
		while(pos.first1() != end_char){
			const auto expression_pos = parse_expression_int(pos, eoperator_precedence::k_super_weak);
			const auto pos2 = skip_expr_whitespace(expression_pos.second);
			const auto ch = pos2.first1();
			if(ch == ","){
				result._elements.push_back(collection_element_t{ nullptr, expression_pos.first._value });
				pos = pos2.rest1();
			}
			else if(ch == end_char){
				result._elements.push_back(collection_element_t{ nullptr, expression_pos.first._value });
				pos = pos2;
			}
			else if(ch == ":"){
				result._has_keys = true;

				const auto pos3 = skip_expr_whitespace(pos2.rest1());
				const auto expression2_pos = parse_expression_int(pos3, eoperator_precedence::k_super_weak);
				const auto pos4 = skip_expr_whitespace(expression2_pos.second);
				const auto ch2 = pos4.first1();
				if(ch2 == ","){
					result._elements.push_back(collection_element_t{ std::make_shared<json_t>(expression_pos.first._value), expression2_pos.first._value });
					pos = pos4.rest1();
				}
				else if(ch2 == end_char){
					result._elements.push_back(collection_element_t{ std::make_shared<json_t>(expression_pos.first._value), expression2_pos.first._value });
					pos = pos4;
				}
				else{
					throw std::runtime_error("Unexpected char \"" + ch + "\" in bounded list " + start_char + " " + end_char + "!");
				}
			}
			else{
				throw std::runtime_error("Unexpected char \"" + ch + "\" in bounded list " + start_char + " " + end_char + "!");
			}
		}
		return { result, pos.rest1() };
	}
}

QUARK_UNIT_TEST("parser", "parse_bounded_list()", "", ""){
	ut_verify_collection(
		QUARK_POS,
		parse_bounded_list(seq_t("(3)xyz"), "(", ")"),
		std::pair<collection_def_t, seq_t>({false, {	{ nullptr, maker__make_constant(value_t::make_int(3))._value }}}, seq_t("xyz"))
	);
}

QUARK_UNIT_TEST("parser", "parse_bounded_list()", "", ""){
	ut_verify_collection(QUARK_POS, parse_bounded_list(seq_t("[]xyz"), "[", "]"), std::pair<collection_def_t, seq_t>({false, {}}, seq_t("xyz")));
}

QUARK_UNIT_TEST("parser", "parse_bounded_list()", "", ""){
	ut_verify_collection(
		QUARK_POS,
		parse_bounded_list(seq_t("[1,2]xyz"), "[", "]"),
		std::pair<collection_def_t, seq_t>(
			{
				false,
				{
					{ nullptr, maker__make_constant(value_t::make_int(1))._value },
					{ nullptr, maker__make_constant(value_t::make_int(2))._value }
				}
			},
			seq_t("xyz")
		)
	);
}

QUARK_UNIT_TEST("parser", "parse_bounded_list()", "blank dict", ""){
	ut_verify_collection(
		QUARK_POS,
		parse_bounded_list(seq_t(R"([:]xyz)"), "[", "]"),
		std::pair<collection_def_t, seq_t>(
			{
				true,
				{}
			},
			seq_t("xyz")
		)
	);
}

QUARK_UNIT_TEST("parser", "parse_bounded_list()", "two elements", ""){
	ut_verify_collection(
		QUARK_POS,
		parse_bounded_list(seq_t(R"(["one": 1, "two": 2]xyz)"), "[", "]"),
		std::pair<collection_def_t, seq_t>(
			{
				true,
				{
					{ std::make_shared<json_t>(maker__make_constant(value_t::make_string("one"))._value), maker__make_constant(value_t::make_int(1))._value },
					{ std::make_shared<json_t>(maker__make_constant(value_t::make_string("two"))._value), maker__make_constant(value_t::make_int(2))._value }
				}
			},
			seq_t("xyz")
		)
	);
}

bool are_keys_used(const collection_def_t& c){
	return c._has_keys;
}

std::vector<json_t> get_values(const collection_def_t& c){
	std::vector<json_t> result;
	for(const auto& e: c._elements){
		result.push_back(e._value);
	}
	return result;
}


/*
Escape sequence	Hex value in ASCII	Character represented
\a	07	Alert (Beep, Bell) (added in C89)[1]
\b	08	Backspace
\f	0C	Formfeed
\n	0A	Newline (Line Feed); see notes below
\r	0D	Carriage Return
\t	09	Horizontal Tab
\v	0B	Vertical Tab
\\	5C	Backslash
\'	27	Single quotation mark
\"	22	Double quotation mark
\?	3F	Question mark (used to avoid trigraphs)
\nnnnote 1	any	The byte whose numerical value is given by nnn interpreted as an octal number
\xhh…	any	The byte whose numerical value is given by hh… interpreted as a hexadecimal number
\enote 2	1B	escape character (some character sets)
\Uhhhhhhhhnote 3	none	Unicode code point where h is a hexadecimal digit
\uhhhhnote 4	none	Unicode code point below 10000 hexadecimal
*/
//??? add tests for this.
char expand_one_char_escape(const char ch2){
	switch(ch2){
		case 'a':
			return 0x07;
		case 'b':
			return 0x08;
		case 'f':
			return 0x0c;
		case 'n':
			return 0x0a;
		case 'r':
			return 0x0d;
		case 't':
			return 0x09;
		case 'v':
			return 0x0b;
		case '\\':
			return 0x5c;
		case '\'':
			return 0x27;
		case '"':
			return 0x22;
		default:
			return 0;
	}
}

std::pair<std::string, seq_t> parse_string_literal(const seq_t& s){
	QUARK_ASSERT(!s.empty());
	QUARK_ASSERT(s.first1_char() == '\"');

	auto pos = s.rest();
	std::string result = "";
	while(pos.empty() == false && pos.first() != "\""){
		//	Look for escape char
		if(pos.first1_char() == 0x5c){
			if(pos.size() < 2){
				throw std::runtime_error("Incomplete escape sequence in string literal: \"" + result + "\"!");
			}
			else{
				const auto ch2 = pos.first(2)[1];
				const char expanded_char = expand_one_char_escape(ch2);
				if(expanded_char == 0x00){
					throw std::runtime_error("Unknown escape character \"" + std::string(1, ch2) + "\" in string literal: \"" + result + "\"!");
				}
				else{
					result += std::string(1, expanded_char);
					pos = pos.rest(2);
				}
			}
		}
		else {
			result += pos.first();
			pos = pos.rest();
		}
	}
	if(pos.first() != "\""){
		throw std::runtime_error("Incomplete string literal -- missing ending \"-character in string literal: \"" + result + "\"!");
	}
	return { result, pos.rest() };
}

QUARK_UNIT_TEST("parser", "parse_string_literal()", "", ""){
	ut_verify(QUARK_POS, parse_string_literal(seq_t(R"("" xxx)")), std::pair<std::string, seq_t>("", seq_t(" xxx")));
}

QUARK_UNIT_TEST("parser", "parse_string_literal()", "", ""){
	ut_verify(QUARK_POS, parse_string_literal(seq_t(R"("hello" xxx)")), std::pair<std::string, seq_t>("hello", seq_t(" xxx")));
}

QUARK_UNIT_TEST("parser", "parse_string_literal()", "", ""){
	ut_verify(QUARK_POS, parse_string_literal(seq_t(R"(".5" xxx)")), std::pair<std::string, seq_t>(".5", seq_t(" xxx")));
}

QUARK_UNIT_TEST("parser", "parse_string_literal()", "", ""){
	ut_verify(
		QUARK_POS,
		//	NOTICE that \" are Floyd-escapes in the Floyd source code.
		parse_string_literal(seq_t(R"___("hello \"Bob\"!" xxx)___")),
		std::pair<std::string, seq_t>(R"(hello "Bob"!)", seq_t(" xxx"))
	);
}

QUARK_UNIT_TEST("parser", "parse_string_literal()", "Escape \t", ""){
	ut_verify(QUARK_POS, parse_string_literal(seq_t(R"___("\t" xxx)___")), std::pair<std::string, seq_t>("\t", seq_t(" xxx")));
}
QUARK_UNIT_TEST("parser", "parse_string_literal()", "Escape \\", ""){
	ut_verify(QUARK_POS, parse_string_literal(seq_t(R"___("\\" xxx)___")), std::pair<std::string, seq_t>("\\", seq_t(" xxx")));
}
QUARK_UNIT_TEST("parser", "parse_string_literal()", "Escape \n", ""){
	ut_verify(QUARK_POS, parse_string_literal(seq_t(R"___("\n" xxx)___")), std::pair<std::string, seq_t>("\n", seq_t(" xxx")));
}
QUARK_UNIT_TEST("parser", "parse_string_literal()", "Escape \r", ""){
	ut_verify(QUARK_POS, parse_string_literal(seq_t(R"___("\r" xxx)___")), std::pair<std::string, seq_t>("\r", seq_t(" xxx")));
}
QUARK_UNIT_TEST("parser", "parse_string_literal()", "Escape \"", ""){
	ut_verify(QUARK_POS, parse_string_literal(seq_t(R"___("\"" xxx)___")), std::pair<std::string, seq_t>("\"", seq_t(" xxx")));
}
QUARK_UNIT_TEST("parser", "parse_string_literal()", "Escape \'", ""){
	ut_verify(QUARK_POS, parse_string_literal(seq_t(R"___("\'" xxx)___")), std::pair<std::string, seq_t>("\'", seq_t(" xxx")));
}



// [0-9] and "."  => numeric constant.
std::pair<value_t, seq_t> parse_numeric_constant(const seq_t& p) {
	QUARK_ASSERT(p.check_invariant());
	QUARK_ASSERT(k_c99_number_chars.find(p.first()) != std::string::npos);

	const auto number_pos = read_while(p, k_c99_number_chars);
	if(number_pos.first.empty()){
		throw std::runtime_error("EEE_WRONG_CHAR");
	}

	//	If it contains a "." its a double, else an int.
	if(number_pos.first.find('.') != std::string::npos){
		const auto number = parse_double(number_pos.first);
		return { value_t::make_double(number), number_pos.second };
	}
	else{
		int number = atoi(number_pos.first.c_str());
		return { value_t::make_int(number), number_pos.second };
	}
}

QUARK_UNIT_TEST("parser", "parse_numeric_constant()", "", ""){
	const auto a = parse_numeric_constant(seq_t("0 xxx"));
	QUARK_UT_VERIFY(a.first.get_int_value() == 0);
	QUARK_UT_VERIFY(a.second.get_s() == " xxx");
}

QUARK_UNIT_TEST("parser", "parse_numeric_constant()", "", ""){
	const auto a = parse_numeric_constant(seq_t("1234 xxx"));
	QUARK_UT_VERIFY(a.first.get_int_value() == 1234);
	QUARK_UT_VERIFY(a.second.get_s() == " xxx");
}

QUARK_UNIT_TEST("parser", "parse_numeric_constant()", "", ""){
	const auto a = parse_numeric_constant(seq_t("0.5 xxx"));
	QUARK_UT_VERIFY(a.first.get_double_value() == 0.5f);
	QUARK_UT_VERIFY(a.second.get_s() == " xxx");
}


/*

	lhs operation EXPR +++
	lhs OPERATION EXPRESSION ...
*/
std::pair<json_t, seq_t> parse_optional_operation_rightward(const seq_t& p0, const json_t& lhs, const eoperator_precedence precedence){
	QUARK_ASSERT(p0.check_invariant());

	const auto p = skip_expr_whitespace(p0);
	if(p.empty()){
		return { lhs, p0 };
	}
	else {
		const auto op1 = p.first();
		const auto op2 = p.first(2);

		//	Detect end of chain. Notice that we leave the ")" or "]".
		if(op1 == ")" && precedence > eoperator_precedence::k_parentesis){
			return { lhs, p0 };
		}

#if 0
		else if(op2 == "//" || op2 == "/*"){
			return { lhs, p0 };
		}
#endif

		else if(op1 == "]" && precedence > eoperator_precedence::k_parentesis){
			return { lhs, p0 };
		}

		//	lhs OPERATOR rhs
		else {
			//	Function call
			//	EXPRESSION (EXPRESSION +, EXPRESSION)
			if(op1 == "(" && precedence > eoperator_precedence::k_function_call){
				const auto a_pos = parse_bounded_list(p, "(", ")");

				if(are_keys_used(a_pos.first)){
					throw std::runtime_error("Cannot name arguments in function call!");
				}
				const auto values = get_values(a_pos.first);
				const auto call = maker__call(lhs, values);
				return parse_optional_operation_rightward(a_pos.second, call._value, precedence);
			}

			//	Member access
			//	EXPRESSION "." EXPRESSION +
			else if(op1 == "."  && precedence > eoperator_precedence::k_member_access){
				const auto identifier_s = read_while(skip_expr_whitespace(p.rest()), k_c99_identifier_chars);
				if(identifier_s.first.empty()){
					throw std::runtime_error("Expected ')'");
				}
				const auto value2 = maker__member_access(lhs, identifier_s.first);

				return parse_optional_operation_rightward(identifier_s.second, value2._value, precedence);
			}

			//	Lookup / subscription
			//	EXPRESSION "[" EXPRESSION "]" +
			else if(op1 == "["  && precedence > eoperator_precedence::k_looup){
				const auto p2 = skip_expr_whitespace(p.rest());
				const auto key = parse_expression_int(p2, eoperator_precedence::k_super_weak);
				const auto result = maker__make2(k_2_operator_to_string.at(eoperation::k_2_lookup), lhs, key.first._value);
				const auto p3 = skip_expr_whitespace(key.second);

				// Closing "]".
				if(p3.first() != "]"){
					throw std::runtime_error("Expected closing \"]\"");
				}
				return parse_optional_operation_rightward(p3.rest(), result._value, precedence);
			}

			//	EXPRESSION "+" EXPRESSION
			else if(op1 == "+"  && precedence > eoperator_precedence::k_add_sub){
				const auto rhs = parse_expression_int(p.rest(), eoperator_precedence::k_add_sub);
				const auto value2 = maker__make2(k_2_operator_to_string.at(eoperation::k_2_add), lhs, rhs.first._value);
				return parse_optional_operation_rightward(rhs.second, value2._value, precedence);
			}

			//	EXPRESSION "-" EXPRESSION
			else if(op1 == "-" && precedence > eoperator_precedence::k_add_sub){
				const auto rhs = parse_expression_int(p.rest(), eoperator_precedence::k_add_sub);
				const auto value2 = maker__make2(k_2_operator_to_string.at(eoperation::k_2_subtract), lhs, rhs.first._value);
				return parse_optional_operation_rightward(rhs.second, value2._value, precedence);
			}

			//	EXPRESSION "*" EXPRESSION
			else if(op1 == "*" && precedence > eoperator_precedence::k_multiply_divider_remainder) {
				const auto rhs = parse_expression_int(p.rest(), eoperator_precedence::k_multiply_divider_remainder);
				const auto value2 = maker__make2(k_2_operator_to_string.at(eoperation::k_2_multiply), lhs, rhs.first._value);
				return parse_optional_operation_rightward(rhs.second, value2._value, precedence);
			}
			//	EXPRESSION "/" EXPRESSION
			else if(op1 == "/" && precedence > eoperator_precedence::k_multiply_divider_remainder) {
				const auto rhs = parse_expression_int(p.rest(), eoperator_precedence::k_multiply_divider_remainder);
				const auto value2 = maker__make2(k_2_operator_to_string.at(eoperation::k_2_divide), lhs, rhs.first._value);
				return parse_optional_operation_rightward(rhs.second, value2._value, precedence);
			}

			//	EXPRESSION "%" EXPRESSION
			else if(op1 == "%" && precedence > eoperator_precedence::k_multiply_divider_remainder) {
				const auto rhs = parse_expression_int(p.rest(), eoperator_precedence::k_multiply_divider_remainder);
				const auto value2 = maker__make2(k_2_operator_to_string.at(eoperation::k_2_remainder), lhs, rhs.first._value);
				return parse_optional_operation_rightward(rhs.second, value2._value, precedence);
			}


			//	EXPRESSION "?" EXPRESSION ":" EXPRESSION
			else if(op1 == "?" && precedence > eoperator_precedence::k_comparison_operator) {
				const auto true_expr_p = parse_expression_int(p.rest(), eoperator_precedence::k_comparison_operator);

				const auto pos2 = skip_expr_whitespace(true_expr_p.second);
				const auto colon = pos2.first();
				if(colon != ":"){
					throw std::runtime_error("Expected \":\"");
				}

				const auto false_expr_p = parse_expression_int(pos2.rest(), precedence);
				const auto value2 = maker__make_conditional_operator(lhs, true_expr_p.first._value, false_expr_p.first._value);
				return parse_optional_operation_rightward(false_expr_p.second, value2._value, precedence);
			}


			//	EXPRESSION "==" EXPRESSION
			else if(op2 == "==" && precedence > eoperator_precedence::k_equal__not_equal){
				const auto rhs = parse_expression_int(p.rest(2), eoperator_precedence::k_equal__not_equal);
				const auto value2 = maker__make2(k_2_operator_to_string.at(eoperation::k_2_logical_equal), lhs, rhs.first._value);
				return parse_optional_operation_rightward(rhs.second, value2._value, precedence);
			}
			//	EXPRESSION "!=" EXPRESSION
			else if(op2 == "!=" && precedence > eoperator_precedence::k_equal__not_equal){
				const auto rhs = parse_expression_int(p.rest(2), eoperator_precedence::k_equal__not_equal);
				const auto value2 = maker__make2(k_2_operator_to_string.at(eoperation::k_2_logical_nonequal), lhs, rhs.first._value);
				return parse_optional_operation_rightward(rhs.second, value2._value, precedence);
			}

			//	!!! Check for "<=" before we check for "<".
			//	EXPRESSION "<=" EXPRESSION
			else if(op2 == "<=" && precedence > eoperator_precedence::k_larger_smaller){
				const auto rhs = parse_expression_int(p.rest(2), eoperator_precedence::k_larger_smaller);
				const auto value2 = maker__make2(k_2_operator_to_string.at(eoperation::k_2_smaller_or_equal), lhs, rhs.first._value);
				return parse_optional_operation_rightward(rhs.second, value2._value, precedence);
			}

			//	EXPRESSION "<" EXPRESSION
			else if(op1 == "<" && precedence > eoperator_precedence::k_larger_smaller){
				const auto rhs = parse_expression_int(p.rest(2), eoperator_precedence::k_larger_smaller);
				const auto value2 = maker__make2(k_2_operator_to_string.at(eoperation::k_2_smaller), lhs, rhs.first._value);
				return parse_optional_operation_rightward(rhs.second, value2._value, precedence);
			}


			//	!!! Check for ">=" before we check for ">".
			//	EXPRESSION ">=" EXPRESSION
			else if(op2 == ">=" && precedence > eoperator_precedence::k_larger_smaller){
				const auto rhs = parse_expression_int(p.rest(2), eoperator_precedence::k_larger_smaller);
				const auto value2 = maker__make2(k_2_operator_to_string.at(eoperation::k_2_larger_or_equal), lhs, rhs.first._value);
				return parse_optional_operation_rightward(rhs.second, value2._value, precedence);
			}

			//	EXPRESSION ">" EXPRESSION
			else if(op1 == ">" && precedence > eoperator_precedence::k_larger_smaller){
				const auto rhs = parse_expression_int(p.rest(2), eoperator_precedence::k_larger_smaller);
				const auto value2 = maker__make2(k_2_operator_to_string.at(eoperation::k_2_larger), lhs, rhs.first._value);
				return parse_optional_operation_rightward(rhs.second, value2._value, precedence);
			}


			//	EXPRESSION "&&" EXPRESSION
			else if(op2 == "&&" && precedence > eoperator_precedence::k_logical_and){
				const auto rhs = parse_expression_int(p.rest(2), eoperator_precedence::k_logical_and);
				const auto value2 = maker__make2(k_2_operator_to_string.at(eoperation::k_2_logical_and), lhs, rhs.first._value);
				return parse_optional_operation_rightward(rhs.second, value2._value, precedence);
			}

			//	EXPRESSION "||" EXPRESSION
			else if(op2 == "||" && precedence > eoperator_precedence::k_logical_or){
				const auto rhs = parse_expression_int(p.rest(2), eoperator_precedence::k_logical_or);
				const auto value2 = maker__make2(k_2_operator_to_string.at(eoperation::k_2_logical_or), lhs, rhs.first._value);
				return parse_optional_operation_rightward(rhs.second, value2._value, precedence);
			}

			//	EXPRESSION
			//	Nope, no operation -- just use the lhs expression on its own.
			else{
				return { lhs, p0 };
			}
		}
	}
}


/*
	Constant literal or identifier.
		3
		3.0
		"three"
		true
		false
		hello2
		x
*/
std::pair<json_t, seq_t> parse_terminal(const seq_t& p0) {
	QUARK_ASSERT(p0.check_invariant());

	const auto p = skip_expr_whitespace(p0);

	//	String literal?
	if(p.first1() == "\""){
		const auto value_pos = parse_string_literal(p);
		const auto result = maker__make_constant(value_t::make_string(value_pos.first));
		return { result._value, value_pos.second };
	}

	//	Number constant?
	// [0-9] and "."  => numeric constant.
	else if(k_c99_number_chars.find(p.first1()) != std::string::npos){
		const auto value_p = parse_numeric_constant(p);
		const auto result = maker__make_constant(value_p.first);
		return { result._value, value_p.second };
	}

	else if(if_first(p, keyword_t::k_true).first){
		const auto result = maker__make_constant(value_t::make_bool(true));
		return { result._value, if_first(p, keyword_t::k_true).second };
	}

	else if(if_first(p, keyword_t::k_false).first){
		const auto result = maker__make_constant(value_t::make_bool(false));
		return { result._value, if_first(p, keyword_t::k_false).second };
	}

	//	Identifier?
	{
		const auto identifier_s = read_while(p, k_c99_identifier_chars);
		if(!identifier_s.first.empty()){
			const auto result = maker__make_identifier(identifier_s.first);
			return { result._value, identifier_s.second };
		}
	}

	throw std::runtime_error("Expected constant or identifier.");
}

void ut_verify_terminal(const std::string& expression, const std::string& expected_value, const std::string& expected_seq){
	const auto result = parse_terminal(seq_t(expression));
	const std::string json_s = expr_to_string(result.first);
	if(json_s == expected_value && result.second.get_s() == expected_seq){
	}
	else{
		QUARK_TRACE_SS("input:" << expression);
		QUARK_TRACE_SS("expect:" << expected_value);
		QUARK_TRACE_SS("result:" << json_s);
		fail_test(QUARK_POS);
	}
}

QUARK_UNIT_TEST("parser", "parse_terminal()", "identifier", ""){
	ut_verify_terminal(
		"123 xxx",
		R"(["k", 123, "^int"])",
		" xxx"
	);
}

QUARK_UNIT_TEST("parser", "parse_terminal()", "identifier", ""){
	ut_verify_terminal(
		"123.5 xxx",
		R"(["k", 123.5, "^double"])",
		" xxx"
	);
}

QUARK_UNIT_TEST("parser", "parse_terminal()", "identifier", ""){
	ut_verify_terminal(
		"0.0 xxx",
		R"(["k", 0, "^double"])",
		" xxx"
	);
}

QUARK_UNIT_TEST("parser", "parse_terminal()", "identifier", ""){
	ut_verify_terminal(
		"hello xxx",
		R"(["@", "hello"])",
		" xxx"
	);
}

QUARK_UNIT_TEST("parser", "parse_terminal()", "identifier", ""){
	ut_verify_terminal(
		R"("world!" xxx)",
		R"(["k", "world!", "^string"])",
		" xxx"
	);
}

QUARK_UNIT_TEST("parser", "parse_terminal()", "identifier", ""){
	ut_verify_terminal(
		R"("" xxx)",
		R"(["k", "", "^string"])",
		" xxx"
	);
}


QUARK_UNIT_TEST("parser", "parse_terminal()", "identifier", ""){
	ut_verify_terminal(
		"true xxx",
		R"(["k", true, "^bool"])",
		" xxx"
	);
}
QUARK_UNIT_TEST("parser", "parse_terminal()", "identifier", ""){
	ut_verify_terminal(
		"false xxx",
		R"(["k", false, "^bool"])",
		" xxx"
	);
}




/*
	Atom = standalone expression, like a constant, a function call.
	It can be composed of subexpressions

	It may then be chained rightwards using operations like "+" etc.

	Examples:
		123
		-123
		--+-123
		(123 + 123 * x + f(y*3))
		[ 1, 2, calc_exp(3) ]
*/
std::pair<json_t, seq_t> parse_lhs_atom(const seq_t& p){
	QUARK_ASSERT(p.check_invariant());

    const auto p2 = skip_expr_whitespace(p);
	if(p2.empty()){
		throw std::runtime_error("Unexpected end of string.");
	}

	const char ch1 = p2.first1_char();

	//	Negate? "-xxx"
	if(ch1 == '-'){
		const auto a = parse_expression_int(p2.rest1(), eoperator_precedence::k_super_strong);
		const auto value2 = maker__make_unary_minus(a.first._value);
		return { value2._value, a.second };
	}
	else if(ch1 == '+'){
		const auto a = parse_expression_int(p2.rest1(), eoperator_precedence::k_super_strong);
		return { a.first._value, a.second };
	}
	//	Expression within parantheses?
	//	(EXPRESSION)xxx"
	else if(ch1 == '('){
		const auto a = parse_expression_int(p2.rest1(), eoperator_precedence::k_super_weak);
		const auto p3 = skip_expr_whitespace(a.second);
		if (p3.first() != ")"){
			throw std::runtime_error("Expected ')'");
		}
		return { a.first._value, p3.rest() };
	}

	else if(is_first(p2, keyword_t::k_struct)){
		throw std::runtime_error("No support for struct definition expressions!");
	}
	else if(is_first(p2, keyword_t::k_protocol)){
		throw std::runtime_error("No support for protocol definition expressions!");
	}

	/*
		Vector definition: "[" EXPRESSION "," EXPRESSION... "]"
		 	[ 1, 2, 3 ]
		 	[ calc_pi(), 2.8, calc_pi * 2.0]
	
		OR

		Dict definition: "{" EXPRESSION ":" EXPRESSION, EXPRESSION ":" EXPRESSION, ... "}"
			{ "one": 1, "two": 2, "three": 3 }
	*/
	else if(ch1 == '['){
		const auto a = parse_bounded_list(p2, "[", "]");
		if(a.first._has_keys){
			throw std::runtime_error("Illegal vector, use {} to make a dictionary!");
		}
		else{
			const auto result = maker_vector_definition("", get_values(a.first));
			return {result._value, a.second };
		}
	}
	else if(ch1 == '{'){
		const auto a = parse_bounded_list(p2, "{", "}");
		if(a.first._elements.size() > 0 && a.first._has_keys == false){
			throw std::runtime_error("Dictionary needs keys!");
		}
		std::vector<json_t> flat_dict;
		for(const auto& b: a.first._elements){
			if(b._key == nullptr){
				throw std::runtime_error("Dictionary definition misses element key(s)!");
			}
			flat_dict.push_back(*b._key);
			flat_dict.push_back(b._value);
		}
		const auto result = maker_dict_definition("", flat_dict);
		return {result._value, a.second };
	}

	//	Single constant number, string literal, function call, variable access, lookup or member access. Can be a chain.
	//	"1234xxx" or "my_function(3)xxx"
	else {
		const auto a = parse_terminal(p2);
		return a;
	}
}

QUARK_UNIT_TEST("parser", "parse_lhs_atom()", "", ""){
	const auto a = parse_lhs_atom(seq_t("3"));
	QUARK_UT_VERIFY(a.first == maker__make_constant(value_t::make_int(3))._value);
}

QUARK_UNIT_TEST("parser", "parse_lhs_atom()", "", ""){
	const auto a = parse_lhs_atom(seq_t("[3]"));
	QUARK_UT_VERIFY(a.first == maker_vector_definition("", std::vector<json_t>{maker__make_constant(value_t::make_int(3))._value})._value);
}


std::pair<std::string, seq_t> test_parse_expression2(const seq_t& expression){
	const auto result = parse_expression2(seq_t(expression));
	return { expr_to_string(result.first._value), result.second };
}

bool test__parse_expression2(const std::string& expression, std::string expected_value, std::string expected_seq){
	QUARK_TRACE_SS("input:" << expression);
	QUARK_TRACE_SS("expect:" << expected_value);

	const auto result = test_parse_expression2(seq_t(expression));
	QUARK_TRACE_SS("result:" << result.first);
	if(result.first != expected_value){
		return false;
	}
	else if(result.second.get_s() != expected_seq){
		return false;
	}
	return true;
}
//??? move to this.
void ut_verify__expression(const std::pair<ast_json_t, seq_t>& result, const std::string& expected_json, const std::string& expected_seq){
	const std::string json_s = expr_to_string(result.first._value);
	if(json_s == expected_json && result.second.get_s() == expected_seq){
	}
	else{
//		QUARK_TRACE_SS("input:" << expression);
		QUARK_TRACE_SS("result:" << json_s);
		QUARK_TRACE_SS("expect:" << expected_json);
		fail_test(QUARK_POS);
	}
}


//////////////////////////////////			EMPTY

QUARK_UNIT_TEST("parser", "parse_expression2()", "", ""){
	try{
		parse_expression2(seq_t(""));
		QUARK_UT_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(std::string(e.what()) == "Unexpected end of string.");
	}
}

//////////////////////////////////			CONSTANTS

QUARK_UNIT_TEST("parser", "parse_expression2()", "", ""){
	ut_verify__expression(parse_expression2(seq_t("0")), R"(["k", 0, "^int"])", "");
}
QUARK_UNIT_TEST("parser", "parse_expression2()", "", ""){
	ut_verify__expression(parse_expression2(seq_t("0 xxx")), R"(["k", 0, "^int"])", " xxx");
}
QUARK_UNIT_TEST("parser", "parse_expression2()", "", ""){
//???
//	ut_verify__expression(parse_expression2(seq_t("1234567890")), "[\"k\", 1234567890, \"^int\"]", "");
}
QUARK_UNIT_TEST("parser", "parse_expression2()", "", ""){
	ut_verify__expression(parse_expression2(seq_t(R"___("hello, world!")___")), R"(["k", "hello, world!", "^string"])", "");
}


//////////////////////////////////			ARITHMETICS

QUARK_UNIT_TEST("parser", "parse_expression2()", "arithmetics", ""){
	ut_verify__expression(parse_expression2(
		seq_t("10 + 4")),
		R"(["+", ["k", 10, "^int"], ["k", 4, "^int"]])",
		""
	);
}
QUARK_UNIT_TEST("parser", "parse_expression2()", "arithmetics", ""){
	ut_verify__expression(
		parse_expression2(seq_t("1 + 2 + 3 + 4")),
		R"(["+", ["+", ["+", ["k", 1, "^int"], ["k", 2, "^int"]], ["k", 3, "^int"]], ["k", 4, "^int"]])",
		""
	);
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "arithmetics", ""){
	ut_verify__expression(
		parse_expression2(seq_t("10 * 4")),
		R"(["*", ["k", 10, "^int"], ["k", 4, "^int"]])",
		""
	);
}
QUARK_UNIT_TEST("parser", "parse_expression2()", "arithmetics", ""){
	ut_verify__expression(
		parse_expression2(seq_t("10 * 4 * 3")),
		R"(["*", ["*", ["k", 10, "^int"], ["k", 4, "^int"]], ["k", 3, "^int"]])",
		""
	);
}
QUARK_UNIT_TEST("parser", "parse_expression2()", "arithmetics", ""){
	ut_verify__expression(
		parse_expression2(seq_t("40 / 4")),
		R"(["/", ["k", 40, "^int"], ["k", 4, "^int"]])",
		""
	);
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "arithmetics", ""){
	ut_verify__expression(
		parse_expression2(seq_t("40 / 5 / 2")),
		R"(["/", ["/", ["k", 40, "^int"], ["k", 5, "^int"]], ["k", 2, "^int"]])",
		""
	);
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "arithmetics", ""){
	ut_verify__expression(
		parse_expression2(seq_t("41 % 5")),
		R"(["%", ["k", 41, "^int"], ["k", 5, "^int"]])",
		""
	);
}
QUARK_UNIT_TEST("parser", "parse_expression2()", "arithmetics", ""){
	ut_verify__expression(
		parse_expression2(seq_t("413 % 50 % 10")),
		R"(["%", ["%", ["k", 413, "^int"], ["k", 50, "^int"]], ["k", 10, "^int"]])",
		""
	);
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "arithmetics", ""){
	ut_verify__expression(
		parse_expression2(seq_t("1 + 3 * 2 + 100")),
		R"(["+", ["+", ["k", 1, "^int"], ["*", ["k", 3, "^int"], ["k", 2, "^int"]]], ["k", 100, "^int"]])",
		""
	);
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "arithmetics", ""){
	ut_verify__expression(
		parse_expression2(seq_t("1 + 8 + 7 + 2 * 3 + 4 * 5 + 6")),
		R"(["+", ["+", ["+", ["+", ["+", ["k", 1, "^int"], ["k", 8, "^int"]], ["k", 7, "^int"]], ["*", ["k", 2, "^int"], ["k", 3, "^int"]]], ["*", ["k", 4, "^int"], ["k", 5, "^int"]]], ["k", 6, "^int"]])",
		""
	);
}


//////////////////////////////////			parantheses

QUARK_UNIT_TEST("parser","parse_expression2()", "parantheses", ""){
	ut_verify__expression(
		parse_expression2(seq_t("(3)")),
		R"(["k", 3, "^int"])",
		""
	);
}
QUARK_UNIT_TEST("parser", "parse_expression2()", "parantheses", ""){
	ut_verify__expression(
		parse_expression2(seq_t("(3 * 8)")),
		R"(["*", ["k", 3, "^int"], ["k", 8, "^int"]])",
		""
	);
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "parantheses", ""){
	ut_verify__expression(
		parse_expression2(seq_t("(3 * 2 + (8 * 2)) - (((1))) * 2")),
		R"(["-", ["+", ["*", ["k", 3, "^int"], ["k", 2, "^int"]], ["*", ["k", 8, "^int"], ["k", 2, "^int"]]], ["*", ["k", 1, "^int"], ["k", 2, "^int"]]])",
		""
	);
}


//////////////////////////////////			vector definition


QUARK_UNIT_TEST("parser", "parse_expression2()", "vector", ""){
	QUARK_UT_VERIFY(test__parse_expression2("[]", R"(["construct-value", ["vector", "^**undef**"], []])", ""));
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "vector", ""){
	QUARK_UT_VERIFY(test__parse_expression2("[1,2,3]", R"(["construct-value", ["vector", "^**undef**"], [["k", 1, "^int"], ["k", 2, "^int"], ["k", 3, "^int"]]])", ""));
}


//////////////////////////////////			DICT definition

QUARK_UNIT_TEST("parser", "parse_expression2()", "dict", ""){
	QUARK_UT_VERIFY(test__parse_expression2("{:}", R"(["construct-value", ["dict", "^**undef**"], []])", ""));
}
QUARK_UNIT_TEST("parser", "parse_expression2()", "dict", ""){
	QUARK_UT_VERIFY(test__parse_expression2("{}", R"(["construct-value", ["dict", "^**undef**"], []])", ""));
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "dict definition", ""){
	QUARK_UT_VERIFY(test__parse_expression2(
		R"({"one": 1, "two": 2, "three": 3})",
		R"(["construct-value", ["dict", "^**undef**"], [["k", "one", "^string"], ["k", 1, "^int"], ["k", "two", "^string"], ["k", 2, "^int"], ["k", "three", "^string"], ["k", 3, "^int"]]])", "")
	);
}


//////////////////////////////////			NEG

QUARK_UNIT_TEST("parser", "parse_expression2()", "unary minus", ""){
	QUARK_UT_VERIFY(test__parse_expression2("-2 xxx", R"(["unary_minus", ["k", 2, "^int"]])", " xxx"));
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "unary minus", ""){
	QUARK_UT_VERIFY(test__parse_expression2(
		"-(3)",
		R"(["unary_minus", ["k", 3, "^int"]])",
		""
	));
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "unary minus", ""){
	QUARK_UT_VERIFY(test__parse_expression2(
		"2---2 xxx",
		R"(["-", ["k", 2, "^int"], ["unary_minus", ["unary_minus", ["k", 2, "^int"]]]])",
		" xxx"
	));
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "unary minus", ""){
	QUARK_UT_VERIFY(test__parse_expression2(
		"2-+-2 xxx",
		R"(["-", ["k", 2, "^int"], ["unary_minus", ["k", 2, "^int"]]])",
		" xxx"
	));
}


//////////////////////////////////			LOGICAL EQUALITY


UNIT_TEST_1("parse_expression2()", "<=", test__parse_expression2(
	"3 <= 4",
	R"(["<=", ["k", 3, "^int"], ["k", 4, "^int"]])",
	""
));
UNIT_TEST_1("parse_expression2()", "<", test__parse_expression2(
	"3 < 4",
	R"(["<", ["k", 3, "^int"], ["k", 4, "^int"]])",
	""
));
UNIT_TEST_1("parse_expression2()", ">=", test__parse_expression2(
	"3 >= 4",
	R"([">=", ["k", 3, "^int"], ["k", 4, "^int"]])",
	""
));
UNIT_TEST_1("parse_expression2()", ">", test__parse_expression2(
	"3 > 4",
	R"([">", ["k", 3, "^int"], ["k", 4, "^int"]])",
	""
));
UNIT_TEST_1("parse_expression2()", "==", test__parse_expression2(
	"3 == 4",
	R"(["==", ["k", 3, "^int"], ["k", 4, "^int"]])",
	""
));
UNIT_TEST_1("parse_expression2()", "==", test__parse_expression2(
	"1==3",
	R"(["==", ["k", 1, "^int"], ["k", 3, "^int"]])",
	""
));
UNIT_TEST_1("parse_expression2()", "!=", test__parse_expression2(
	"3 != 4",
	R"(["!=", ["k", 3, "^int"], ["k", 4, "^int"]])",
	""
));

UNIT_TEST_1("parse_expression2()", "&&", test__parse_expression2(
	"3 && 4",
	R"(["&&", ["k", 3, "^int"], ["k", 4, "^int"]])",
	""
));
UNIT_TEST_1("parse_expression2()", "&&", test__parse_expression2(
	"3 && 4 && 5",
	R"(["&&", ["&&", ["k", 3, "^int"], ["k", 4, "^int"]], ["k", 5, "^int"]])",
	""
));
UNIT_TEST_1("parse_expression2()", "&&", test__parse_expression2(
	"1 * 1 && 0 * 1",
	R"(["&&", ["*", ["k", 1, "^int"], ["k", 1, "^int"]], ["*", ["k", 0, "^int"], ["k", 1, "^int"]]])",
	""
));

UNIT_TEST_1("parse_expression2()", "||", test__parse_expression2(
	"3 || 4",
	R"(["||", ["k", 3, "^int"], ["k", 4, "^int"]])",
	""
));
UNIT_TEST_1("parse_expression2()", "||", test__parse_expression2(
	"3 || 4 || 5",
	R"(["||", ["||", ["k", 3, "^int"], ["k", 4, "^int"]], ["k", 5, "^int"]])",
	""
));
UNIT_TEST_1("parse_expression2()", "||", test__parse_expression2(
	"1 * 1 || 0 * 1",
	R"(["||", ["*", ["k", 1, "^int"], ["k", 1, "^int"]], ["*", ["k", 0, "^int"], ["k", 1, "^int"]]])",
	""
));

//??? Check combos of || and &&


//////////////////////////////////			IDENTIFIERS


UNIT_TEST_1("parse_expression2()", "identifier", test__parse_expression2(
	"hello xxx",
	R"(["@", "hello"])",
	" xxx"
));


//////////////////////////////////			COMPARISON OPERATOR

UNIT_TEST_1("parse_expression2()", "?:", test__parse_expression2(
	"1 ? 2 : 3 xxx",
	R"(["?:", ["k", 1, "^int"], ["k", 2, "^int"], ["k", 3, "^int"]])",
	" xxx"
));

UNIT_TEST_1("parse_expression2()", "?:", test__parse_expression2(
	"1==3 ? 4 : 6 xxx",
	R"(["?:", ["==", ["k", 1, "^int"], ["k", 3, "^int"]], ["k", 4, "^int"], ["k", 6, "^int"]])",
	" xxx"
));

UNIT_TEST_1("parse_expression2()", "?:", test__parse_expression2(
	"1 ? \"true!!!\" : \"false!!!\" xxx",
	R"(["?:", ["k", 1, "^int"], ["k", "true!!!", "^string"], ["k", "false!!!", "^string"]])",
	" xxx"
));

UNIT_TEST_1("parse_expression2()", "?:", test__parse_expression2(
	"1 + 2 ? 3 + 4 : 5 + 6 xxx",
	R"(["?:", ["+", ["k", 1, "^int"], ["k", 2, "^int"]], ["+", ["k", 3, "^int"], ["k", 4, "^int"]], ["+", ["k", 5, "^int"], ["k", 6, "^int"]]])",
	" xxx"
));

//??? Add more test to see precedence works as it should!


UNIT_TEST_1("parse_expression2()", "?:", test__parse_expression2(
	"input_flag ? \"123\" : \"456\"",
	R"(["?:", ["@", "input_flag"], ["k", "123", "^string"], ["k", "456", "^string"]])",
	""
));


UNIT_TEST_1("parse_expression2()", "?:", test__parse_expression2(
	"input_flag ? 100 + 10 * 2 : 1000 - 3 * 4",
	R"(["?:", ["@", "input_flag"], ["+", ["k", 100, "^int"], ["*", ["k", 10, "^int"], ["k", 2, "^int"]]], ["-", ["k", 1000, "^int"], ["*", ["k", 3, "^int"], ["k", 4, "^int"]]]])",
	""
));


//////////////////////////////////			FUNCTION CALLS

UNIT_TEST_1("parse_expression2()", "function call", test__parse_expression2(
	"f() xxx",
	R"(["call", ["@", "f"], []])",
	" xxx"
));

UNIT_TEST_1("parse_expression2()", "function call, one simple arg",
	test__parse_expression2(
		"f(3)",
		R"(["call", ["@", "f"], [["k", 3, "^int"]]])",
		""
	)
);

UNIT_TEST_1("parse_expression2()", "call with expression-arg", test__parse_expression2(
	"f(x+10) xxx",
	R"(["call", ["@", "f"], [["+", ["@", "x"], ["k", 10, "^int"]]]])",
	" xxx"
));
UNIT_TEST_1("parse_expression2()", "call with expression-arg", test__parse_expression2(
	"f(1,2) xxx",
	R"(["call", ["@", "f"], [["k", 1, "^int"], ["k", 2, "^int"]]])",
	" xxx"
));
UNIT_TEST_1("parse_expression2()", "call with expression-arg -- whitespace", test__parse_expression2(
	"f ( 1 , 2 ) xxx",
	R"(["call", ["@", "f"], [["k", 1, "^int"], ["k", 2, "^int"]]])",
	" xxx"
));

UNIT_TEST_1("parse_expression2()", "function call with expression-args", test__parse_expression2(
	"f(3 + 4, 4 * g(1000 + 2345), \"hello\", 5)",
	R"(["call", ["@", "f"], [["+", ["k", 3, "^int"], ["k", 4, "^int"]], ["*", ["k", 4, "^int"], ["call", ["@", "g"], [["+", ["k", 1000, "^int"], ["k", 2345, "^int"]]]]], ["k", "hello", "^string"], ["k", 5, "^int"]]])",
	""
));

QUARK_UNIT_TEST("parser", "parse_expression2()", "function call, expression argument", ""){
	const auto result = test_parse_expression2(seq_t("1 == 2)"));
	QUARK_UT_VERIFY((		result == std::pair<std::string, seq_t>( R"(["==", ["k", 1, "^int"], ["k", 2, "^int"]])", ")" )		));
}


QUARK_UNIT_TEST("parser", "parse_expression2()", "function call, expression argument", ""){
	const auto result = test_parse_expression2(seq_t("f(1 == 2)"));
	QUARK_UT_VERIFY((		result == std::pair<std::string, seq_t>( R"(["call", ["@", "f"], [["==", ["k", 1, "^int"], ["k", 2, "^int"]]]])", "" )		));
}


QUARK_UNIT_TEST("parser", "parse_expression2()", "function call", ""){
	const auto result = test_parse_expression2(seq_t("((3))))"));
}
QUARK_UNIT_TEST("parser", "parse_expression2()", "function call", ""){
	const auto result = test_parse_expression2(seq_t("print((3))))"));
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "function call", ""){
	const auto result = test_parse_expression2(seq_t("print(1 < 2)"));
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "function call", ""){
	const auto result = test_parse_expression2(seq_t("print(1 < color(1, 2, 3))"));
}


QUARK_UNIT_TEST("parser", "parse_expression2()", "function call", ""){
	const auto result = test_parse_expression2(seq_t("print(color(1, 2, 3) < color(1, 2, 3))"));
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "function call", ""){
	QUARK_UT_VERIFY(
		test__parse_expression2(
			"print(color(1, 2, 3) == file(404)) xxx",
			R"___(["call", ["@", "print"], [["==", ["call", ["@", "color"], [["k", 1, "^int"], ["k", 2, "^int"], ["k", 3, "^int"]]], ["call", ["@", "file"], [["k", 404, "^int"]]]]]])___",
			" xxx"
		)
	)
}


//////////////////////////////////			MEMBER ACCESS

QUARK_UNIT_TEST("parser", "parse_expression2()", "struct member access", ""){
	QUARK_UT_VERIFY(test__parse_expression2("hello.kitty xxx", R"(["->", ["@", "hello"], "kitty"])", " xxx"));
}

UNIT_TEST_1("parse_expression2()", "struct member access", test__parse_expression2(
	"hello.kitty.cat xxx",
	R"(["->", ["->", ["@", "hello"], "kitty"], "cat"])",
	" xxx"
));

UNIT_TEST_1("parse_expression2()", "struct member access -- whitespace", test__parse_expression2(
	"hello . kitty . cat xxx",
	R"(["->", ["->", ["@", "hello"], "kitty"], "cat"])",
	" xxx"
));


//////////////////////////////////			LOOKUP

UNIT_TEST_1("parse_expression2()", "lookup with int", test__parse_expression2(
	"hello[10] xxx",
	R"(["[]", ["@", "hello"], ["k", 10, "^int"]])",
	" xxx"
));

UNIT_TEST_1("parse_expression2()", "lookup with string", test__parse_expression2(
	R"(hello["troll"] xxx)",
	R"(["[]", ["@", "hello"], ["k", "troll", "^string"]])",
	" xxx"
));

UNIT_TEST_1("parse_expression2()", "lookup with string -- whitespace", test__parse_expression2(
	R"(hello [ "troll" ] xxx)",
	R"(["[]", ["@", "hello"], ["k", "troll", "^string"]])",
	" xxx"
));


//////////////////////////////////			COMBOS


UNIT_TEST_1("parse_expression2()", "combo - function call", test__parse_expression2(
	"poke.mon.f() xxx",
	R"(["call", ["->", ["->", ["@", "poke"], "mon"], "f"], []])",
	" xxx"
));

UNIT_TEST_1("parse_expression2()", "combo - function call", test__parse_expression2(
	"f().g() xxx",
	R"(["call", ["->", ["call", ["@", "f"], []], "g"], []])",
	" xxx"
));


UNIT_TEST_1("parse_expression2()", "complex chain", test__parse_expression2(
	R"(hello["troll"].kitty[10].cat xxx)",
	R"(["->", ["[]", ["->", ["[]", ["@", "hello"], ["k", "troll", "^string"]], "kitty"], ["k", 10, "^int"]], "cat"])",
	" xxx"
));


UNIT_TEST_1("parse_expression2()", "chain", test__parse_expression2(
	R"(poke.mon.v[10].a.b.c["three"] xxx)",
	R"(["[]", ["->", ["->", ["->", ["[]", ["->", ["->", ["@", "poke"], "mon"], "v"], ["k", 10, "^int"]], "a"], "b"], "c"], ["k", "three", "^string"]])",
	" xxx"
));

UNIT_TEST_1("parse_expression2()", "combo arithmetics", test__parse_expression2(
	" 5 - 2 * ( 3 ) xxx",
	R"(["-", ["k", 5, "^int"], ["*", ["k", 2, "^int"], ["k", 3, "^int"]]])",
	" xxx"
));


//////////////////////////////////			EXPRESSION ERRORS


void test__parse_expression__throw(const std::string& expression, const std::string& exception_message){
	try{
		const auto result = parse_expression2(seq_t(expression));
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		const std::string es(e.what());
		if(!exception_message.empty()){
			QUARK_TEST_VERIFY(es == exception_message);
		}
	}
}


QUARK_UNIT_TEST("parser", "parse_expression2()", "Parentheses error", ""){
	test__parse_expression__throw("5*((1+3)*2+1", "");
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "Parentheses error", ""){
//	test__parse_expression__throw("5*((1+3)*2)+1)", "");
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "Repeated operators (wrong)", ""){
	test__parse_expression__throw("5*/2", "");
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "Wrong position of an operator", ""){
	test__parse_expression__throw("*2", "");
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "Wrong position of an operator", ""){
	test__parse_expression__throw("2+", "Unexpected end of string.");
}
QUARK_UNIT_TEST("parser", "parse_expression2()", "Wrong position of an operator", ""){
	test__parse_expression__throw("2*", "Unexpected end of string.");
}


QUARK_UNIT_TEST("parser", "parse_expression2()", "Invalid characters", ""){
	test__parse_expression__throw("~5", "Illegal characters.");
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "Invalid characters", ""){
	test__parse_expression__throw("~5", "");
}

QUARK_UNIT_TEST("parser", "parse_expression2()", "Invalid characters", ""){
//	test__parse_expression__throw("5x", "EEE_WRONG_CHAR");
}


QUARK_UNIT_TEST("parser", "parse_expression2()", "Invalid characters", ""){
	test__parse_expression__throw("2/", "Unexpected end of string.");
}





std::pair<ast_json_t, seq_t> parse_expression_int(const seq_t& p, const eoperator_precedence precedence){
	QUARK_ASSERT(p.check_invariant());

	auto lhs = parse_lhs_atom(p);
	const auto r = parse_optional_operation_rightward(lhs.second, lhs.first, precedence);
	return { ast_json_t::make(r.first), r.second };
}

std::pair<ast_json_t, seq_t> parse_expression2(const seq_t& p){
	if(!is_valid_expr_chars(p.get_s())){
		throw std::runtime_error("Illegal characters.");
	}
	return parse_expression_int(p, eoperator_precedence::k_super_weak);
}

std::pair<ast_json_t, seq_t> parse_expression_seq(const seq_t& expression){
	const auto expr = parse_expression2(expression);
	return { expr.first, expr.second };
}


}	//	floyd
