	test__run_init__check_result("let int result = 123", value_t::make_int(123));


	test__run_init__check_result("let string result = \"xyz\"", value_t::make_string("xyz"));


	test__run_init__check_result("let int result = 1 + 2", value_t::make_int(3));
	const auto r = test__run_global("print(5)");



print("Hello, world!")

	const auto r = test__run_global("let a = 10;print(a)");





	test__run_init__check_result("let int result = true ? 1 : 2", value_t::make_int(1));


	test__run_init__check_result("let bool result = \"adwark\" < \"boat\"", value_t::make_bool(true));
}

		R"(
			func string main(string args){
				return "123" + "456"
			}
		)",




	test__run_main("func bool main(){ return 4 < 5 }", {}, value_t::make_bool(true));



	test__run_init__check_result("let result = json_value(123)", value_t::make_json_value(json_t(123.0)));

	test__run_init__check_result("let result = json_value(\"hello\")", value_t::make_json_value(json_t("hello")));


	test__run_init__check_result("let result = json_value([1,2,3])", value_t::make_json_value(json_t::make_array({1,2,3})));


		"struct pixel_t { int red int green int blue } result = pixel_t(1,2,3)",




		"result = [[int]]([1,2,3], [4,5,6]);",



		R"(result = [{string: int}]({"a":1,"b":2,"c":3}, {"d":4,"e":5,"f":6});)",




//////////////////////////////////////////		CALL FUNCTIONS



		func int myfunc(){ return 5 }
		func int main(string args){
			return myfunc() + myfunc() * 2
		}



		func string myfunc(string t){ return "<" + t + ">" }
		func string main(string args){
			 let string a = "--"
			 let string b = myfunc(args)
			 return a + args + b + a
		}



		mutable a = 1
		a = 2
		print(a)





				mutable a = 7
				a = 8
				{
					print(a)
				}







		func string f(){
			print("A")
			return "B"
			print("C")
			return "D"
		}
		let string x = f()
		print(x)





		func string f(){
			for(e in 0...3){
				print("A")
				return "B"
				print("C")
			}
			print("D")
			return "E"
		}
		let string x = f()
		print(x)






		func string f(){
			{
				print("A")
				return "B"
				print("C")
			}
			print("D")
			return "E"
		}
		let string x = f()
		print(x)






			let string result = to_string(145)
		)",
		value_t::make_string("145")


			let string result = to_string(3.1)
		value_t::make_string("3.1")



			let string result = to_string(3.0)
		)",
		value_t::make_string("3")












			let result = to_string(typeof("hello"))
	ut_compare_values(result, value_t::make_string("string"));
}


		let result = typeof([1,2,3])
	ut_compare_values(result, value_t::make_typeid_value(typeid_t::make_vector(typeid_t::make_int())));




let result = to_string(typeof([1,2,3]))
ut_compare_values(result, value_t::make_string("[int]"));






		print("Hello, World!")




			assert(1 == 2)



		R"(
			t = typeof(1234);
			result = instantiate_from_typeid(t, 3);
		)", {}
	);





QUARK_UNIT_TESTQ("run_init()", "if"){
	const auto r = test__run_global(
		R"(
			if(1 == 1){
				print("one")
			}
			else if(2 == 0){
				print("two")
			}
			else if(3 == 0){
				print("three")
			}
			else{
				print("four")
			}
		)"
	);
	QUARK_UT_VERIFY((r->_print_output == vector<string>{ "one" }));
}






		R"(
			for (i in 0...2) {
				print("Iteration: " + to_string(i))
			}
		)"
	);


		R"(
			for (i in 0..<2) {
				print("Iteration: " + to_string(i))
			}
		)"





		func int fibonacci(int n) {
			if (n <= 1){
				return n
			}
			return fibonacci(n - 2) + fibonacci(n - 1)
		}

		for (i in 0...10) {
			print(fibonacci(i))
		}





		mutable a = 100
		while(a < 105){
			print(to_string(a))
			a = a + 1
		}






		assert("hello"[0] == 104)


		assert("hello"[4] == 111)
		assert(size("How long is this string?") == 24)



		a = push_back("one", 111)
		assert(a == "oneo")


		a = update("hello", 1, 98)


		assert(subset("abc", 0, 3) == "abc")
		assert(subset("abc", 1, 3) == "bc")
		assert(subset("abc", 0, 0) == "")


		assert(replace("One ring to rule them all", 4, 8, "rabbit") == "One rabbit to rule them all")





		let a = ["one", "two"]

		let [string] a = ["one", "two"]


		let [string] a = []




//////////////////////////////////////////		vector-string

	test_result(R"(		let [string] result = ["alpha", "beta"]		)", R"(		[[ "vector", "^string" ], ["alpha","beta"]]		)");


}


func string get_beta(){ return "beta" }
let [string] result = ["alpha", get_beta()]




assert((["one", "two"] == ["one", "two"]) == true)



assert((["one", "two"] < ["one", "two"]) == false)


let [string] a = ["one", "two"]
assert(size(a) == 2)


let [string] a = ["one"] + ["two"]
assert(a == ["one", "two"])


let [string] a = push_back(["one"], "two")
assert(a == ["one", "two"])






let [int] result = [10, 20, 30]
let a = [10, 20, 30] 
let result = [1, 2] == [1, 2]
let [int] result = push_back([1, 2], 3)



let result = [1.5, 2.5] < [1.5, 3.5]



assert(find([1,2,3], 4) == -1)
assert(find([1,2,3], 1) == 0)
assert(find([1,2,2,2,3], 2) == 1)


assert(find("hello, world", "he") == 0)
assert(find("hello, world", "e") == 1)
assert(find("hello, world", "x") == -1)




assert(subset([10,20,30], 0, 3) == [10,20,30])

assert(subset([10,20,30], 1, 3) == [20,30])
result = (subset([10,20,30], 0, 0) == [])
assert(subset([10,20,30], 0, 0) == [])





assert(
	replace(
		[ 1, 2, 3, 4, 5, 6 ], 2, 5, [20, 30]
	) == [1, 2, 20, 30, 6]
)





let a = [ "one", "two", "three"]
let b = update(a, 1, "zwei")
assert(a == ["one","two","three"])
assert(b == ["one","zwei","three"])




let [string: int] a = {"one": 1, "two": 2}

let [string: int] a = {"one": 1, "two": 2}
print(a["one"])
print(a["two"])



mutable a = {}
a = {"hello": 1}
print(a)



let a = {}



let a = {"one": 1, "two": 2}
print(a)




QUARK_UNIT_TEST("dict", "{}", "", ""){
	const auto vm = test__run_global(R"(
		mutable [string:int] a = {}
		a = {}
		print(a)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		R"({})",
	});
}

QUARK_UNIT_TEST("dict", "==", "", ""){
	const auto vm = test__run_global(R"(
		assert(({"one": 1, "two": 2} == {"one": 1, "two": 2}) == true)
	)");
}
QUARK_UNIT_TEST("dict", "==", "", ""){
	const auto vm = test__run_global(R"(
		assert(({"one": 1, "two": 2} == {"two": 2}) == false)
	)");
}
QUARK_UNIT_TEST("dict", "==", "", ""){
	const auto vm = test__run_global(R"(
		assert(({"one": 2, "two": 2} == {"one": 1, "two": 2}) == false)
	)");
}
QUARK_UNIT_TEST("dict", "==", "", ""){
	const auto vm = test__run_global(R"(
		assert(({"one": 1, "two": 2} < {"one": 1, "two": 2}) == false)
	)");
}
QUARK_UNIT_TEST("dict", "==", "", ""){
	const auto vm = test__run_global(R"(
		assert(({"one": 1, "two": 1} < {"one": 1, "two": 2}) == true)
	)");
}

QUARK_UNIT_TEST("dict", "size()", "[:]", "correct size"){
	try{
		const auto vm = test__run_global(R"(
			assert(size({}) == 0)
		)");
		QUARK_UT_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Cannot resolve type.");
	}
}

QUARK_UNIT_TEST("dict", "size()", "[:]", "correct type"){
	try{
		const auto vm = test__run_global(R"(
			print({})
		)");
		QUARK_UT_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Cannot resolve type.");
	}
}

QUARK_UNIT_TEST("dict", "size()", "[:]", "correct size"){
	const auto vm = test__run_global(R"(
		assert(size({"one":1}) == 1)
	)");
}
QUARK_UNIT_TEST("dict", "size()", "[:]", "correct size"){
	const auto vm = test__run_global(R"(
		assert(size({"one":1, "two":2}) == 2)
	)");
}

QUARK_UNIT_TEST("dict", "update()", "add element", "valid dict, without side effect on original dict"){
	const auto vm = test__run_global(R"(
		let a = { "one": 1, "two": 2}
		let b = update(a, "three", 3)
		print(a)
		print(b)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		R"({"one": 1, "two": 2})",
		R"({"one": 1, "three": 3, "two": 2})"
	});
}

QUARK_UNIT_TEST("dict", "update()", "replace element", ""){
	const auto vm = test__run_global(R"(
		let a = { "one": 1, "two": 2, "three" : 3}
		let b = update(a, "three", 333)
		print(a)
		print(b)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		R"({"one": 1, "three": 3, "two": 2})",
		R"({"one": 1, "three": 333, "two": 2})"
	});
}

QUARK_UNIT_TEST("dict", "update()", "dest is empty dict", ""){
	try{
		const auto vm = test__run_global(R"(
			let a = update({}, "one", 1)
			let b = update(a, "two", 2)
			print(b)
			assert(a == {"one": 1})
			assert(b == {"one": 1, "two": 2})
		)");

		QUARK_UT_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Cannot resolve type.");
	}
}

QUARK_UNIT_TEST("dict", "exists()", "", ""){
	const auto vm = test__run_global(R"(
		let a = { "one": 1, "two": 2, "three" : 3}
		assert(exists(a, "two") == true)
		assert(exists(a, "four") == false)
	)");
}

QUARK_UNIT_TEST("dict", "erase()", "", ""){
	const auto vm = test__run_global(R"(
		let a = { "one": 1, "two": 2, "three" : 3}
		let b = erase(a, "one")
		assert(b == { "two": 2, "three" : 3})
	)");
}


//////////////////////////////////////////		STRUCT - TYPE


QUARK_UNIT_TESTQ("run_main()", "struct"){
	const auto vm = test__run_global(R"(
		struct t {}
	)");
}

QUARK_UNIT_TESTQ("run_main()", "struct"){
	const auto vm = test__run_global(R"(
		struct t { int a }
	)");
}

QUARK_UNIT_TEST("run_main()", "struct - check struct's type", "", ""){
	const auto vm = test__run_global(R"(
		struct t { int a }
		print(t)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"struct {int a;}"
	});
}

QUARK_UNIT_TESTQ("run_main()", "struct - check struct's type"){
	const auto vm = test__run_global(R"(
		struct t { int a }
		let a = t(3)
		print(a)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		 R"({a=3})"
	});
}

QUARK_UNIT_TESTQ("run_main()", "struct - read back struct member"){
	const auto vm = test__run_global(R"(
		struct t { int a }
		let temp = t(4)
		print(temp.a)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"4"
	});
}

QUARK_UNIT_TEST("run_main()", "struct - instantiate nested structs", "", ""){
	const auto vm = test__run_global(R"(
		struct color { int red int green int blue }
		struct image { color back color front }

		let c = color(128, 192, 255)
		print(c)
		let i = image(color(1, 2, 3), color(200, 201, 202))
		print(i)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"{red=128, green=192, blue=255}",
		"{back={red=1, green=2, blue=3}, front={red=200, green=201, blue=202}}"
	});
}

QUARK_UNIT_TEST("run_main()", "struct - access member of nested structs", "", ""){
	const auto vm = test__run_global(R"(
		struct color { int red int green int blue }
		struct image { color back color front }
		let i = image(color(1, 2, 3), color(200, 201, 202))
		print(i.front.green)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"201"
	});
}

QUARK_UNIT_TEST("run_main()", "return struct from function", "", ""){
	const auto vm = test__run_global(R"(
		struct color { int red int green int blue }
		struct image { color back color front }
		func color make_color(){
			return color(100, 101, 102)
		}
		let z = make_color()
		print(z)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"{red=100, green=101, blue=102}",
	});
}

QUARK_UNIT_TEST("run_main()", "return struct from function", "", ""){
	const auto vm = test__run_global(R"(
		struct color { int red int green int blue }
		struct image { color back color front }
		func color make_color(){
			return color(100, 101, 102)
		}
		print(make_color())
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"{red=100, green=101, blue=102}",
	});
}

QUARK_UNIT_TESTQ("run_main()", "struct - compare structs"){
	const auto vm = test__run_global(R"(
		struct color { int red int green int blue }
		print(color(1, 2, 3) == color(1, 2, 3))
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"true"
	});
}

QUARK_UNIT_TESTQ("run_main()", "struct - compare structs"){
	const auto vm = test__run_global(R"(
		struct color { int red int green int blue }
		print(color(9, 2, 3) == color(1, 2, 3))
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"false"
	});
}

QUARK_UNIT_TESTQ("run_main()", "struct - compare structs different types"){
	try {
		const auto vm = test__run_global(R"(
			struct color { int red int green int blue }
			struct file { int id }
			print(color(1, 2, 3) == file(404))
		)");
		QUARK_UT_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Expression type mismatch.");
	}
}

QUARK_UNIT_TESTQ("run_main()", "struct - compare structs with <, different types"){
	const auto vm = test__run_global(R"(
		struct color { int red int green int blue }
		print(color(1, 2, 3) < color(1, 2, 3))
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"false"
	});
}

QUARK_UNIT_TESTQ("run_main()", "struct - compare structs <"){
	const auto vm = test__run_global(R"(
		struct color { int red int green int blue }
		print(color(1, 2, 3) < color(1, 4, 3))
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"true"
	});
}


QUARK_UNIT_TESTQ("run_main()", "update struct manually"){
	const auto vm = test__run_global(R"(
		struct color { int red int green int blue }
		let a = color(255, 128, 128)
		let b = color(a.red, a.green, 129)
		print(a)
		print(b)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"{red=255, green=128, blue=128}",
		"{red=255, green=128, blue=129}"
	});
}


QUARK_UNIT_TEST("run_main()", "mutate struct member using = won't work", "", ""){
	try {
		const auto vm = test__run_global(R"(
			struct color { int red int green int blue }
			let a = color(255,128,128)
			let b = a.green = 3
			print(a)
			print(b)
		)");
	}
	catch(...){
	}
}

QUARK_UNIT_TESTQ("run_main()", "mutate struct member using update()"){
	const auto vm = test__run_global(R"(
		struct color { int red int green int blue }
		let a = color(255,128,128)
		let b = update(a, "green", 3)
		print(a)
		print(b)
	)");

	ut_compare_stringvects(vm->_print_output, vector<string>{
		"{red=255, green=128, blue=128}",
		"{red=255, green=3, blue=128}",
	});
}

QUARK_UNIT_TEST("run_main()", "mutate nested member", "", ""){
	const auto vm = test__run_global(R"(
		struct color { int red int green int blue }
		struct image { color back color front }
		let a = image(color(0,100,200), color(0,0,0))
		let b = update(a, "front.green", 3)
		print(a)
		print(b)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"{back={red=0, green=100, blue=200}, front={red=0, green=0, blue=0}}",
		"{back={red=0, green=100, blue=200}, front={red=0, green=3, blue=0}}"
	});
}


/*
QUARK_UNIT_TEST("run_main()", "struct definition expression", "", ""){
	const auto vm = test__run_global(R"(
		color = struct { int red; int green; int blue;};
		a = color(255, 128, 128);
		b = color(a.red, a.green, 129);
		print(a);
		print(b);
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"{red=255, green=128, blue=128}",
		"{red=255, green=128, blue=129}"
	});
}
*/


#if 0
//////////////////////////////////////////		PROTOCOL - TYPE


QUARK_UNIT_TESTQ("run_main()", "protocol"){
	const auto vm = test__run_global(R"(
		protocol t {}
	)");
}

QUARK_UNIT_TESTQ("run_main()", "protocol"){
	const auto vm = test__run_global(R"(
		protocol t { int a }
	)");
}

QUARK_UNIT_TEST("run_main()", "protocol - check protocol's type", "", ""){
	const auto vm = test__run_global(R"(
		protocol t { int a }
		print(t)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"protocol {int a;}"
	});
}
#endif


//////////////////////////////////////////


QUARK_UNIT_TEST("", "", "", ""){
	const auto vm = test__run_global(R"(
		let start = get_time_of_day()
		mutable b = 0
		mutable t = [0]
		for(i in 0...100){
			b = b + 1
			t = push_back(t, b)
		}
		end = get_time_of_day()
		print("Duration: " + to_string(end - start) + ", number = " + to_string(b))
		print(t)
	)");
	QUARK_UT_VERIFY(true);
}

//////////////////////////////////////////		Comments


QUARK_UNIT_TESTQ("comments", "// on start of line"){
	const auto vm = test__run_global(R"(
		//	XYZ
		print("Hello")
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"Hello"
	});
}

QUARK_UNIT_TEST("comments", "// on start of line", "", ""){
	const auto vm = test__run_global(R"(
		print("Hello")		//	XYZ
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"Hello"
	});
}

QUARK_UNIT_TEST("comments", "// on start of line", "", ""){
	const auto vm = test__run_global(R"(
		print("Hello")/* xyz */print("Bye")
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"Hello",
		"Bye"
	});
}


//////////////////////////////////////////		json_value - TYPE


QUARK_UNIT_TEST("json_value-string", "deduce json_value::string", "", ""){
	const auto result = test__run_return_result(R"(
		let json_value result = "hello"
	)", {});
	ut_compare_values(result, value_t::make_json_value("hello"));
}

QUARK_UNIT_TEST("json_value-string", "string-size()", "", ""){
	const auto result = test__run_return_result(R"(
		let json_value a = "hello"
		let result = size(a);
	)", {});
	ut_compare_values(result, value_t::make_int(5));
}

QUARK_UNIT_TEST("json_value-number", "construct number", "", ""){
	const auto result = test__run_return_result(R"(
		let json_value result = 13
	)", {});
	ut_compare_values(result, value_t::make_json_value(13));
}

QUARK_UNIT_TEST("json_value-bool", "construct true", "", ""){
	const auto result = test__run_return_result(R"(
		let json_value result = true
	)", {});
	ut_compare_values(result, value_t::make_json_value(true));
}
QUARK_UNIT_TEST("json_value-bool", "construct false", "", ""){
	const auto result = test__run_return_result(R"(
		let json_value result = false
	)", {});
	ut_compare_values(result, value_t::make_json_value(false));
}

QUARK_UNIT_TEST("json_value-array", "construct array", "", ""){
	const auto result = test__run_return_result(R"(
		let json_value result = ["hello", "bye"]
	)", {});
	ut_compare_values(result, value_t::make_json_value(json_t::make_array(vector<json_t>{"hello", "bye"})));
}

QUARK_UNIT_TEST("json_value-array", "read array member", "", ""){
	const auto result = test__run_return_result(R"(
		let json_value a = ["hello", "bye"]
		let result = string(a[0]) + string(a[1])
	)", {});
	ut_compare_values(result, value_t::make_string("hellobye"));
}
QUARK_UNIT_TEST("json_value-array", "read array member", "", ""){
	const auto result = test__run_return_result(R"(
		let json_value a = ["hello", "bye"]
		let result = a[0]
	)", {});
	ut_compare_values(result, value_t::make_json_value("hello"));
}
QUARK_UNIT_TEST("json_value-array", "read array member", "", ""){
	const auto result = test__run_return_result(R"(
		let json_value a = ["hello", "bye"]
		let result = a[1]
	)", {});
	ut_compare_values(result, value_t::make_json_value("bye"));
}

QUARK_UNIT_TEST("json_value-array", "size()", "", ""){
	const auto result = test__run_return_result(R"(
		let json_value a = ["a", "b", "c", "d"]
		let result = size(a)
	)", {});
	ut_compare_values(result, value_t::make_int(4));
}

//	NOTICE: Floyd dict is stricter than JSON -- cannot have different types of values!
QUARK_UNIT_TEST("json_value-object", "def", "mix value-types in dict", ""){
	const auto vm = test__run_global(R"(
		let json_value a = { "pigcount": 3, "pigcolor": "pink" }
		print(a)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		R"({ "pigcolor": "pink", "pigcount": 3 })"
	});
}

// JSON example snippets: http://json.org/example.html
QUARK_UNIT_TEST("json_value-object", "def", "read world data", ""){
	const auto vm = test__run_global(R"ABCD(
		let json_value a = {
			"menu": {
			  "id": "file",
			  "value": "File",
			  "popup": {
				"menuitem": [
				  {"value": "New", "onclick": "CreateNewDoc()"},
				  {"value": "Open", "onclick": "OpenDoc()"},
				  {"value": "Close", "onclick": "CloseDoc()"}
				]
			  }
			}
		}
		print(a)
	)ABCD");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		R"ABCD({ "menu": { "id": "file", "popup": { "menuitem": [{ "onclick": "CreateNewDoc()", "value": "New" }, { "onclick": "OpenDoc()", "value": "Open" }, { "onclick": "CloseDoc()", "value": "Close" }] }, "value": "File" } })ABCD"
	});
}

QUARK_UNIT_TEST("json_value-object", "{}", "expressions inside def", ""){
	const auto vm = test__run_global(R"(
		let json_value a = { "pigcount": 1 + 2, "pigcolor": "pi" + "nk" }
		print(a)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		R"({ "pigcolor": "pink", "pigcount": 3 })"
	});
}

QUARK_UNIT_TEST("json_value-object", "{}", "", ""){
	const auto vm = test__run_global(R"(
		let json_value a = { "pigcount": 3, "pigcolor": "pink" }
		print(a["pigcount"])
		print(a["pigcolor"])
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"3",
		"\"pink\""
	});
}

QUARK_UNIT_TEST("json_value-object", "size()", "", ""){
	const auto vm = test__run_global(R"(
		let json_value a = { "a": 1, "b": 2, "c": 3, "d": 4, "e": 5 }
		assert(size(a) == 5)
	)");
}


QUARK_UNIT_TEST("json_value-null", "construct null", "", ""){
	const auto result = test__run_return_result(R"(
		let json_value result = null
	)", {});
	ut_compare_values(result, value_t::make_json_value(json_t()));
}


//////////////////////////////////////////		TEST TYPE DEDUCING

QUARK_UNIT_TEST("", "get_json_type()", "{}", ""){
	const auto result = test__run_return_result(R"(
		let json_value result = {}
	)", {});
	ut_compare_values(result, value_t::make_json_value(json_t::make_object()));
}

//////////////////////////////////////////		json_value features


QUARK_UNIT_TEST("", "get_json_type()", "{}", ""){
	const auto result = test__run_return_result(R"(
		let result = get_json_type(json_value({}))
	)", {});
	ut_compare_values(result, value_t::make_int(1));
}
QUARK_UNIT_TEST("", "get_json_type()", "[]", ""){
	const auto result = test__run_return_result(R"(
		let result = get_json_type(json_value([]))
	)", {});
	ut_compare_values(result, value_t::make_int(2));
}
QUARK_UNIT_TEST("", "get_json_type()", "string", ""){
	const auto result = test__run_return_result(R"(
		let result = get_json_type(json_value("hello"))
	)", {});
	ut_compare_values(result, value_t::make_int(3));
}
QUARK_UNIT_TEST("", "get_json_type()", "number", ""){
	const auto result = test__run_return_result(R"(
		let result = get_json_type(json_value(13))
	)", {});
	ut_compare_values(result, value_t::make_int(4));
}
QUARK_UNIT_TEST("", "get_json_type()", "number", ""){
	const auto result = test__run_return_result(R"(
		let result = get_json_type(json_value(true))
	)", {});
	ut_compare_values(result, value_t::make_int(5));
}
QUARK_UNIT_TEST("", "get_json_type()", "number", ""){
	const auto result = test__run_return_result(R"(
		let result = get_json_type(json_value(false))
	)", {});
	ut_compare_values(result, value_t::make_int(6));
}

QUARK_UNIT_TEST("", "get_json_type()", "null", ""){
	const auto result = test__run_return_result(R"(
		let result = get_json_type(json_value(null))
	)", {});
	ut_compare_values(result, value_t::make_int(7));
}

QUARK_UNIT_TEST("", "get_json_type()", "DOCUMENTATION SNIPPET", ""){
	const auto vm = test__run_global(R"ABCD(
		func string get_name(json_value value){
			t = get_json_type(value)
			if(t == json_object){
				return "json_object"
			}
			else if(t == json_array){
				return "json_array"
			}
			else if(t == json_string){
				return "json_string"
			}
			else if(t == json_number){
				return "json_number"
			}
			else if(t == json_true){
				return "json_true"
			}
			else if(t == json_false){
				return "json_false"
			}
			else if(t == json_null){
				return "json_null"
			}
			else {
				assert(false)
			}
		}

		assert(get_name(json_value({"a": 1, "b": 2})) == "json_object")
		assert(get_name(json_value([1,2,3])) == "json_array")
		assert(get_name(json_value("crash")) == "json_string")
		assert(get_name(json_value(0.125)) == "json_number")
		assert(get_name(json_value(true)) == "json_true")
		assert(get_name(json_value(false)) == "json_false")
	)ABCD");
}


QUARK_UNIT_TEST("", "", "", ""){
	const auto result = test__run_return_result(R"(
		struct pixel_t { double x double y }
		let a = pixel_t(100.0, 200.0)
		let result = a.x
	)", {});
	ut_compare_values(result, value_t::make_double(100.0));
}


QUARK_UNIT_TEST("", "", "", ""){
	const auto result = test__run_return_result(R"(
		struct pixel_t { double x double y }
		let c = [pixel_t(100.0, 200.0), pixel_t(101.0, 201.0)]
		let result = c[1].y
	)", {});
	ut_compare_values(result, value_t::make_double(201.0));
}

QUARK_UNIT_TEST("", "", "", ""){
	try{
		const auto result = test__run_return_result(R"(
			struct pixel_t { double x double y }

			//	c is a json_value::object
			let c = { "version": "1.0", "image": [pixel_t(100.0, 200.0), pixel_t(101.0, 201.0)] }
			let result = c["image"][1].y
		)", {});
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Dict can not hold elements of different type!");
	}
}


//////////////////////////////////////////		decode_json()


QUARK_UNIT_TEST("", "decode_json()", "", ""){
	const auto result = test__run_return_result(R"(
		let result = decode_json("\"genelec\"")
	)", {});
	ut_compare_values(result, value_t::make_json_value(json_t("genelec")));
}

QUARK_UNIT_TEST("", "decode_json()", "", ""){
	const auto vm = test__run_global(R"(
		let a = decode_json("{ \"magic\": 1234 }")
		print(a)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		R"({ "magic": 1234 })"
	});
}


//////////////////////////////////////////		encode_json()


QUARK_UNIT_TEST("", "encode_json()", "", ""){
	const auto vm = test__run_global(R"(
		let json_value a = "cheat"
		let b = encode_json(a)
		print(b)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"\"cheat\""
	});
}


QUARK_UNIT_TEST("", "encode_json()", "", ""){
	const auto vm = test__run_global(R"(
		let json_value a = { "magic": 1234 }
		let b = encode_json(a)
		print(b)
	)");
	ut_compare_stringvects(vm->_print_output, vector<string>{
		"{ \"magic\": 1234 }"
	});
}


//////////////////////////////////////////		flatten_to_json()


QUARK_UNIT_TEST("", "flatten_to_json()", "bool", ""){
	const auto result = test__run_return_result(R"(
		let result = flatten_to_json(true)
	)", {});
	ut_compare_values(result, value_t::make_json_value(json_t(true)));
}
QUARK_UNIT_TEST("", "flatten_to_json()", "bool", ""){
	const auto result = test__run_return_result(R"(
		let result = flatten_to_json(false)
	)", {});
	ut_compare_values(result, value_t::make_json_value(json_t(false)));
}

QUARK_UNIT_TEST("", "flatten_to_json()", "int", ""){
	const auto result = test__run_return_result(R"(
		let result = flatten_to_json(789)
	)", {});
	ut_compare_values(result, value_t::make_json_value(json_t(789.0)));
}
QUARK_UNIT_TEST("", "flatten_to_json()", "int", ""){
	const auto result = test__run_return_result(R"(
		let result = flatten_to_json(-987)
	)", {});
	ut_compare_values(result, value_t::make_json_value(json_t(-987.0)));
}

QUARK_UNIT_TEST("", "flatten_to_json()", "double", ""){
	const auto result = test__run_return_result(R"(
		let result = flatten_to_json(-0.125)
	)", {});
	ut_compare_values(result, value_t::make_json_value(json_t(-0.125)));
}


QUARK_UNIT_TEST("", "flatten_to_json()", "string", ""){
	const auto result = test__run_return_result(R"(
		let result = flatten_to_json("fanta")
	)", {});
	ut_compare_values(result, value_t::make_json_value(json_t("fanta")));
}

QUARK_UNIT_TEST("", "flatten_to_json()", "typeid", ""){
	const auto result = test__run_return_result(R"(
		let result = flatten_to_json(typeof([2,2,3]))
	)", {});
	ut_compare_values(result, value_t::make_json_value(json_t::make_array(vector<json_t>{ "vector", "int"})));
}

QUARK_UNIT_TEST("", "flatten_to_json()", "[]", ""){
	const auto result = test__run_return_result(R"(
		let result = flatten_to_json([1,2,3])
	)", {});
	ut_compare_values(result, value_t::make_json_value(
		json_t::make_array(vector<json_t>{1,2,3})
	));
}

QUARK_UNIT_TEST("", "flatten_to_json()", "{}", ""){
	const auto result = test__run_return_result(R"(
		let result = flatten_to_json({"ten": 10, "eleven": 11})
	)", {});
	ut_compare_values(result, value_t::make_json_value(
		json_t::make_object(std::map<string,json_t>{{"ten", 10},{"eleven", 11}})
	));
}

QUARK_UNIT_TEST("", "flatten_to_json()", "pixel_t", ""){
	const auto result = test__run_return_result(R"(
		struct pixel_t { double x double y }
		let c = pixel_t(100.0, 200.0)
		let a = flatten_to_json(c)
		let result = encode_json(a)
	)", {});
	ut_compare_values(result, value_t::make_string("{ \"x\": 100, \"y\": 200 }"));
}

QUARK_UNIT_TEST("", "flatten_to_json()", "[pixel_t]", ""){
	const auto result = test__run_return_result(R"(
		struct pixel_t { double x double y }
		let c = [pixel_t(100.0, 200.0), pixel_t(101.0, 201.0)]
		let a = flatten_to_json(c)
		let result = encode_json(a)
	)", {});
	ut_compare_values(result, value_t::make_string("[{ \"x\": 100, \"y\": 200 }, { \"x\": 101, \"y\": 201 }]"));
}


//////////////////////////////////////////		flatten_to_json() -> unflatten_from_json() roundtrip


QUARK_UNIT_TEST("", "unflatten_from_json()", "bool", ""){
	const auto result = test__run_return_result(R"(
		let result = unflatten_from_json(flatten_to_json(true), bool)
	)", {});
	ut_compare_values(result, value_t::make_bool(true));
}
QUARK_UNIT_TEST("", "unflatten_from_json()", "bool", ""){
	const auto result = test__run_return_result(R"(
		let result = unflatten_from_json(flatten_to_json(false), bool)
	)", {});
	ut_compare_values(result, value_t::make_bool(false));
}

QUARK_UNIT_TEST("", "unflatten_from_json()", "int", ""){
	const auto result = test__run_return_result(R"(
		let result = unflatten_from_json(flatten_to_json(91), int)
	)", {});
	ut_compare_values(result, value_t::make_int(91));
}

QUARK_UNIT_TEST("", "unflatten_from_json()", "double", ""){
	const auto result = test__run_return_result(R"(
		let result = unflatten_from_json(flatten_to_json(-0.125), double)
	)", {});
	ut_compare_values(result, value_t::make_double(-0.125));
}

QUARK_UNIT_TEST("", "unflatten_from_json()", "string", ""){
	const auto result = test__run_return_result(R"(
		let result = unflatten_from_json(flatten_to_json(""), string)
	)", {});
	ut_compare_values(result, value_t::make_string(""));
}

QUARK_UNIT_TEST("", "unflatten_from_json()", "string", ""){
	const auto result = test__run_return_result(R"(
		let result = unflatten_from_json(flatten_to_json("cola"), string)
	)", {});
	ut_compare_values(result, value_t::make_string("cola"));
}


/*
Need better way to specify typeid
QUARK_UNIT_TEST("", "unflatten_from_json()", "[]", ""){
	const auto result = test__run_return_result(R"(
		result = unflatten_from_json(flatten_to_json([1,2,3]), typeof([1]));
	)", {});
	ut_compare_values(
		result,
		value_t::make_vector_value(typeid_t::make_int(), vector<value_t>{value_t::make_int(1), value_t::make_int(2), value_t::make_int(3)})
	);
}
*/


QUARK_UNIT_TEST("", "unflatten_from_json()", "point_t", ""){
	const auto point_t_def = std::make_shared<floyd::struct_definition_t>(
		std::vector<member_t>{
			member_t(typeid_t::make_double(), "x"),
			member_t(typeid_t::make_double(), "y")
		}
	);
	const auto result = test__run_return_result(R"(
		struct point_t { double x double y }
		let result = unflatten_from_json(flatten_to_json(point_t(1.0, 3.0)), point_t)
	)", {});
	ut_compare_values(result, value_t::make_struct_value(typeid_t::make_struct(point_t_def), vector<value_t>{ value_t::make_double(1), value_t::make_double(3)}));
}


//??? test accessing array->struct->array.
//??? test structs in vectors.


QUARK_UNIT_TEST("Edge case", "", "if with non-bool expression", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			if("not a bool"){
			}
			else{
				assert(false)
			}
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Boolean condition required.");
	}
}

QUARK_UNIT_TEST("Edge case", "", "assign to immutable local", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			let int a = 10
			let int a = 11
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Local identifier already exists.");
	}
}
QUARK_UNIT_TEST("Edge case", "", "Define struct with colliding name", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			let int a = 10
			struct a { int x }
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Name already used.");
	}
}

QUARK_UNIT_TEST("Edge case", "", "Access unknown struct member", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			struct a { int x }
			let b = a(13)
			print(b.y)
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Unknown struct member \"y\".");
	}
}

QUARK_UNIT_TEST("Edge case", "", "Access unknown member in non-struct", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			let a = 10
			print(a.y)
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Parent is not a struct.");
	}
}

QUARK_UNIT_TEST("Edge case", "", "Lookup in string using non-int", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			let string a = "test string"
			print(a["not an integer"])
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Lookup in string by index-only.");
	}
}

QUARK_UNIT_TEST("Edge case", "", "Lookup in vector using non-int", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			let [string] a = ["one", "two", "three"]
			print(a["not an integer"])
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Lookup in vector by index-only.");
	}
}

QUARK_UNIT_TEST("Edge case", "", "Lookup in dict using non-string key", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			let a = { "one": 1, "two": 2 }
			print(a[3])
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Lookup in dict by string-only.");
	}
}

QUARK_UNIT_TEST("Edge case", "", "Access undefined variable", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			print(a)
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Undefined variable \"a\".");
	}
}

QUARK_UNIT_TEST("Edge case", "", "Wrong number of arguments in function call", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			func int f(int a){ return a + 1 }
			let a = f(1, 2)
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Wrong number of arguments in function call.");
	}
}


QUARK_UNIT_TEST("Edge case", "", "Wrong number of arguments to struct-constructor", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			struct pos { double x double y }
			let a = pos(3)
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Wrong number of arguments in function call.");
	}
}

QUARK_UNIT_TEST("Edge case", "", "Wrong TYPE of arguments to struct-constructor", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			struct pos { double x double y }
			let a = pos(3, "hello")
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Expression type mismatch.");
	}
}

QUARK_UNIT_TEST("Edge case", "", "Wrong number of arguments to int-constructor", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			let a = int()
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Wrong number of arguments in function call.");
	}
}

QUARK_UNIT_TEST("Edge case", "", "Call non-function, non-struct, non-typeid", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			let a = 3()
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Cannot call non-function.");
	}
}

//??? check dict too
QUARK_UNIT_TEST("Edge case", "", "Vector can not hold elements of different types.", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			let a = [3, bool]
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Vector can not hold elements of different types.");
	}
}


QUARK_UNIT_TEST("Edge case", "", ".", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			let a = 3 < "hello"
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Expression type mismatch.");
	}
}

QUARK_UNIT_TEST("Edge case", "", ".", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			let a = 3 * 3.2
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Expression type mismatch.");
	}
}
QUARK_UNIT_TEST("Edge case", "Adding bools", ".", "success"){
	const auto result = test__run_return_result(R"(
		let result = false + true
	)", {});
	QUARK_ASSERT(result.get_bool_value() == true);
}
QUARK_UNIT_TEST("Edge case", "Adding bools", ".", "success"){
	const auto result = test__run_return_result(R"(
		let result = false + false
	)", {});
	QUARK_ASSERT(result.get_bool_value() == false);
}
QUARK_UNIT_TEST("Edge case", "Adding bools", ".", "success"){
	const auto result = test__run_return_result(R"(
		let result = true + true
	)", {});
	QUARK_ASSERT(result.get_bool_value() == true);
}

QUARK_UNIT_TEST("Edge case", "", "Lookup the unlookupable", "exception"){
	try{
		const auto result = test__run_return_result(R"(
			let a = 3[0]
		)", {});
		QUARK_TEST_VERIFY(false);
	}
	catch(const std::runtime_error& e){
		QUARK_TEST_VERIFY(string(e.what()) == "Lookup using [] only works with strings, vectors, dicts and json_value.");
	}
}


QUARK_UNIT_TEST("vector-int", "size()", "3", ""){
	const auto result = test__run_return_result(R"(
		let [int] a = [1, 2, 3]
		let result = size(a)
	)", {});
	ut_compare_values(result, value_t::make_int(3));
}
QUARK_UNIT_TEST("vector-int", "size()", "3", ""){
	const auto result = test__run_return_result(R"(
		let result = push_back([1, 2], 3)
		assert(result == [1, 2, 3])
	)", {});
}





OFF_QUARK_UNIT_TEST("Analyse all test programs", "", "", ""){
	const auto t = quark::trace_context_t(false, quark::get_trace());
	interpreter_context_t context{ t };

	int instruction_count_total = 0;
	int symbol_count_total = 0;

	for(const auto& s: program_recording){
		try{
		const auto bc = compile_to_bytecode(context, s);
		int instruction_count_sum = static_cast<int>(bc._globals._instrs2.size());
		int symbol_count_sum = static_cast<int>(bc._globals._symbols.size());

		for(const auto& f: bc._function_defs){
			if(f._frame_ptr != nullptr){
				const auto instruction_count = f._frame_ptr->_instrs2.size();
				const auto symbol_count = f._frame_ptr->_symbols.size();
				instruction_count_sum += instruction_count;
				symbol_count_sum += symbol_count;
			}
		}

		instruction_count_total += instruction_count_sum;
		symbol_count_total += symbol_count_sum;
		QUARK_TRACE_SS(instruction_count_sum << "\t" <<symbol_count_sum);
		}
		catch(...){
		}
	}

	QUARK_TRACE_SS("TOTAL: " << instruction_count_total << "\t" <<symbol_count_total);
}

















///////////////////////////////////////////////////////////////////////////////////////
//	FLOYD SYSTEMS TESTS
///////////////////////////////////////////////////////////////////////////////////////




QUARK_UNIT_TEST("software-system", "test parsing all data", "", ""){
	const auto test_ss = R"(
		software-system {
			"name": "My Arcade Game",
			"desc": "Space shooter for mobile devices, with connection to a server.",

			"people": {
				"Gamer": "Plays the game on one of the mobile apps",
				"Curator": "Updates achievements, competitions, make custom on-off maps",
				"Admin": "Keeps the system running"
			},
			"connections": [
				{ "source": "Game", "dest": "iphone app", "interaction": "plays", "tech": "" }
			],
			"containers": {
				"gmail mail server": {},

				"iphone app": {
					"tech": "Swift, iOS, Xcode, Open GL",
					"desc": "Mobile shooter game for iOS.",

					"clocks": {
						"main": {
							"a": "my_gui_main",
							"b": "iphone-ux"
						},

						"com-clock": {
							"c": "server_com"
						},
						"opengl_feeder": {
							"d": "renderer"
						}
					},
					"connections": [
						{ "source": "b", "dest": "a", "interaction": "b sends messages to a", "tech": "OS call" },
						{ "source": "b", "dest": "c", "interaction": "b also sends messages to c, which is another clock", "tech": "OS call" }
					],
					"components": [
						"My Arcade Game-iphone-app",
						"My Arcade Game-logic",
						"My Arcade Game-servercom",
						"OpenGL-component",
						"Free Game Engine-component",
						"iphone-ux-component"
					]
				},

				"Android app": {
					"tech": "Kotlin, Javalib, Android OS, OpenGL",
					"desc": "Mobile shooter game for Android OS.",
	 
					"clocks": {
						"main": {
							"a": "my_gui_main",
							"b": "iphone-ux"
						},
						"com-clock": {
							"c": "server_com"
						},
						"opengl_feeder": {
							"d": "renderer"
						}
					},
					"components": [
						"My Arcade Game-android-app",
						"My Arcade Game-logic",
						"My Arcade Game-servercom",
						"OpenGL-component",
						"Free Game Engine-component",
						"Android-ux-component"
					]
				},
				"Game Server with players & admin web": {
					"tech": "Django, Pythong, Heroku, Postgres",
					"desc": "The database that stores all user accounts, levels and talks to the mobile apps and handles admin tasks.",

					"clocks": {
						"main": {}
					},
					"components": [
						"My Arcade Game-logic",
						"My Arcade Game server logic"
					]
				}
			}
		}
		result = 123
	)";

	const auto result = test__run_return_result(test_ss, {});
	ut_compare_values(result, value_t::make_int(123));
}

QUARK_UNIT_TEST("software-system", "run one process", "", ""){
	const auto test_ss2 = R"(
		software-system {
			"name": "My Arcade Game",
			"desc": "Space shooter for mobile devices, with connection to a server.",
			"people": {},
			"connections": [],
			"containers": {
				"iphone app": {
					"tech": "Swift, iOS, Xcode, Open GL",
					"desc": "Mobile shooter game for iOS.",
					"clocks": {
						"main": {
							"a": "my_gui",
						}
					}
				}
			}
		}

		struct my_gui_state_t {
			int _count
		}

		func my_gui_state_t my_gui__init(){
			send("a", "dec")
			send("a", "dec")
			send("a", "stop")
			return my_gui_state_t(1000)
		}

		func my_gui_state_t my_gui(my_gui_state_t state, json_value message){
			if(message == "inc"){
				return update(state, "_count", state._count + 1)
			}
			else if(message == "dec"){
				return update(state, "_count", state._count - 1)
			}
			else{
				assert(false)
			}
		}
	)";

	program_recording.push_back(test_ss2);
	const auto context = make_test_interpreter_context();
	run_container(context, test_ss2, {}, "iphone app");
}

QUARK_UNIT_TEST("software-system", "run two unconnected processs", "", ""){
	const auto test_ss3 = R"(
		software-system {
			"name": "My Arcade Game",
			"desc": "Space shooter for mobile devices, with connection to a server.",
			"people": {},
			"connections": [],
			"containers": {
				"iphone app": {
					"tech": "Swift, iOS, Xcode, Open GL",
					"desc": "Mobile shooter game for iOS.",
					"clocks": {
						"main": {
							"a": "my_gui",
							"b": "my_audio",
						}
					}
				}
			}
		}


		////////////////////////////////	my_gui -- process

		struct my_gui_state_t {
			int _count
		}

		func my_gui_state_t my_gui__init(){
			send("a", "dec")
			send("a", "dec")
			send("a", "dec")
			send("a", "stop")
			return my_gui_state_t(1000)
		}

		func my_gui_state_t my_gui(my_gui_state_t state, json_value message){
			if(message == "inc"){
				return update(state, "_count", state._count + 1)
			}
			else if(message == "dec"){
				return update(state, "_count", state._count - 1)
			}
			else{
				assert(false)
			}
		}


		////////////////////////////////	my_audio -- process

		struct my_audio_state_t {
			int _audio
		}

		func my_audio_state_t my_audio__init(){
			send("b", "process")
			send("b", "process")
			send("b", "stop")
			return my_audio_state_t(0)
		}

		func my_audio_state_t my_audio(my_audio_state_t state, json_value message){
			if(message == "process"){
				return update(state, "_audio", state._audio + 1)
			}
			else{
				assert(false)
			}
		}
	)";

	program_recording.push_back(test_ss3);
	const auto context = make_test_interpreter_context();
	const auto result = run_container(context, test_ss3, {}, "iphone app");
	QUARK_UT_VERIFY(result.size() == 2);
	QUARK_UT_VERIFY(result.at("a").get_struct_value()->_member_values[0].get_int_value() == 997);
	QUARK_UT_VERIFY(result.at("b").get_struct_value()->_member_values[0].get_int_value() == 2);
}


QUARK_UNIT_TEST("software-system", "run two CONNECTED processes", "", ""){
	const auto test_ss3 = R"(
		software-system {
			"name": "My Arcade Game",
			"desc": "Space shooter for mobile devices, with connection to a server.",
			"people": {},
			"connections": [],
			"containers": {
				"iphone app": {
					"tech": "Swift, iOS, Xcode, Open GL",
					"desc": "Mobile shooter game for iOS.",
					"clocks": {
						"main": {
							"a": "my_gui",
							"b": "my_audio",
						}
					}
				}
			}
		}


		////////////////////////////////	my_gui -- process

		struct my_gui_state_t {
			int _count
		}

		func my_gui_state_t my_gui__init(){
			return my_gui_state_t(1000)
		}

		func my_gui_state_t my_gui(my_gui_state_t state, json_value message){
			if(message == "2"){
				send("b", "3")
				return update(state, "_count", state._count + 1)
			}
			else if(message == "4"){
				send("a", "stop")
				send("b", "stop")
				return update(state, "_count", state._count + 10)
			}
			else{
				assert(false)
			}
		}


		////////////////////////////////	my_audio -- process

		struct my_audio_state_t {
			int _audio
		}

		func my_audio_state_t my_audio__init(){
			send("b", "1")
			return my_audio_state_t(0)
		}

		func my_audio_state_t my_audio(my_audio_state_t state, json_value message){
			if(message == "1"){
				send("a", "2")
				return update(state, "_audio", state._audio + 1)
			}
			else if(message == "3"){
				send("a", "4")
				return update(state, "_audio", state._audio + 4)
			}
			else{
				assert(false)
			}
		}
	)";

	program_recording.push_back(test_ss3);
	const auto context = make_test_interpreter_context();
	const auto result = run_container(context, test_ss3, {}, "iphone app");
	QUARK_UT_VERIFY(result.size() == 2);
	QUARK_UT_VERIFY(result.at("a").get_struct_value()->_member_values[0].get_int_value() == 1011);
	QUARK_UT_VERIFY(result.at("b").get_struct_value()->_member_values[0].get_int_value() == 5);
}
